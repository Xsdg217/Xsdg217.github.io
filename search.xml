<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Transverse-field Ising Model</title>
    <url>/2022/10/18/HW_TF_Ising_model/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size=5>Homework(task3)</font>

<ul>
<li><p>consider the transverse-field Ising model on a N-site ring. please take both sets of parameters for homework:</p>
</li>
<li><p>$(a) J = 1, g = 1.7 \; (b) J = 1, g = 0.7$</p>
</li>
</ul>
<script type="math/tex; mode=display">
\begin{gathered}
H=-J \sum_{i=1}^N\left(g \sigma_i^x+\sigma_i^z \sigma_{i+1}^z\right) \\
\sigma^x=\left(\begin{array}{ll}
0 & 1 \\
1 & 0
\end{array}\right), \sigma^z=\left(\begin{array}{cc}
1 & 0 \\
0 & -1
\end{array}\right)
\end{gathered}</script><ul>
<li><p>(1) write a code to calculate the dispersion relation E(k) of this model,<br>show the eigenvalues in each momentum sector for N = 8</p>
</li>
<li><p>(2) for N = 6, show that the eigenvalues agree with the exact solution</p>
</li>
<li>hint: it depends on fermion parity and parameters</li>
</ul>
<p><font size=4>简单思路分析</font></p>
<ul>
<li>首先我们分析一下 transverse-field Ising model 的对称性。由 $\sigma^{x}$ 和 $\sigma^{z}$ 的矩阵表示可知：<script type="math/tex; mode=display">
\begin{gathered}
\sigma^x |\uparrow > = |\downarrow >  \\
\sigma^x |\downarrow > = |\uparrow >  \\
\sigma^z |\uparrow > = |\uparrow >  \\
\sigma^z |\downarrow > = - |\downarrow > 
\end{gathered}</script></li>
<li>$<br>  H=-J \sum_{i=1}^N\left(g \sigma_i^x+\sigma_i^z \sigma_{i+1}^z\right)<br>$<br>表明，其横场作用项的效果是一个 Flip ，从而导致总自旋不守恒，即没有 $U(1)$ symmetry；不过可以证明 $[H,T]=0$，哈密顿量与平移算符有对易关系，即体系有 translational symmetry</li>
<li>定义 project : $P_k=\dfrac{1}{N} \sum_{j=0}^{N-1} e^{i \frac{2 \pi}{N} k j} T^j$，归一化的动量空间基矢和在此基矢下的哈密顿矩阵元表示为：</li>
</ul>
<script type="math/tex; mode=display">
\left|r_k\right\rangle=\frac{P_k|r\rangle}{\sqrt{\left\langle r\left|P_k^{\dagger} P_k\right| r\right\rangle}}=\frac{P_k|r\rangle}{\sqrt{\left\langle r\left|P_k\right| r\right\rangle}}</script><script type="math/tex; mode=display">
\left\langle r_k^{\prime}|H| r_k\right\rangle=\frac{\left\langle r^{\prime}\left|P_k^{\dagger} H P_k\right| r\right\rangle}{\sqrt{\left\langle r^{\prime}\left|P_k\right| r^{\prime}\right\rangle\left\langle r\left|P_k\right| r\right\rangle}}=\frac{\left\langle r^{\prime}\left|P_k H\right| r\right\rangle}{\sqrt{\left\langle r^{\prime}\left|P_k\right| r^{\prime}\right\rangle\left\langle r\left|P_k\right| r\right\rangle}}</script><ul>
<li>以 $N=4$ 为例，下图是只考虑平移对称性时的块对角化哈密顿矩阵：</li>
</ul>
<div  align="center">    
<img src=https://s2.loli.net/2022/10/17/PhRBHrWQNu4YAfj.png style="zoom:50%" />
</div>


<ul>
<li><p>only translational symmetry:  (1+1+2+1+1) + (1+1+1) + (1+2+1) + (1+1+1) = 16</p>
</li>
<li><p>下面是具体代码实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一题，N=8，求E(k)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LA</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span></span><br><span class="line">PI = np.pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReadBit</span>(<span class="params">i,n</span>):                                   <span class="comment">#读取i的第n位</span></span><br><span class="line">    <span class="keyword">return</span> (i&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FlipBit</span>(<span class="params">i,n</span>):                                   <span class="comment">#翻转i的第n位                            </span></span><br><span class="line">    <span class="keyword">return</span> i^(<span class="number">1</span>&lt;&lt;n)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PickBit</span>(<span class="params">i,k,n</span>):                                 <span class="comment">#从i的第k位开始截取n位</span></span><br><span class="line">    <span class="keyword">return</span> (i&amp;((<span class="number">2</span>**n-<span class="number">1</span>))&lt;&lt;k)&gt;&gt;k</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RotLBit</span>(<span class="params">i,L,n</span>):                                 <span class="comment">#长度为L的i的n位左移</span></span><br><span class="line">    <span class="keyword">return</span> (PickBit(i,<span class="number">0</span>,L-n)&lt;&lt;n)+(i&gt;&gt;(L-n))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PopCntBit</span>(<span class="params">i</span>):                                   <span class="comment">#i态中“1”的个数             </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(i).count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">T</span>(<span class="params">state,k,N</span>):                                     <span class="comment">#平移算符就是RotLBit(state,N,k)</span></span><br><span class="line">    <span class="keyword">return</span> RotLBit(state,N,k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Findmin</span>(<span class="params">state,N</span>):                                 <span class="comment">#寻找平移算符作用在state态上能得到的值最小的态，这个态作为“代表性基矢”</span></span><br><span class="line">    ans = state</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        tmp = T(state, i, N)</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; ans):</span><br><span class="line">            ans = tmp</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Pk</span>(<span class="params">r,k,N</span>):                                        <span class="comment">#算符 P_k 作用在态 r 上得到的态，返回值是一个矢量</span></span><br><span class="line">    n = <span class="number">1</span>&lt;&lt;N</span><br><span class="line">    res = np.zeros(n,dtype=<span class="built_in">complex</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        res[T(r,i,N)] += np.exp(<span class="number">2</span>*PI*k*i/N * <span class="number">1.0j</span>) / N <span class="comment">#定义</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PkH</span>(<span class="params">r,k,P,g,N</span>):                                     <span class="comment">#算符 P_k * H 作用在态 r 上得到的态，返回值是一个矢量</span></span><br><span class="line">    n = <span class="number">1</span>&lt;&lt;N</span><br><span class="line">    Hr = np.zeros(n,dtype=<span class="built_in">complex</span> )</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):                              <span class="comment">#sigma_x 横场项</span></span><br><span class="line">        Hr[FlipBit(r,i)] = -J * g                   </span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> site <span class="keyword">in</span> <span class="built_in">range</span>(N):                           <span class="comment">#sigma_z 经典Ising项</span></span><br><span class="line">        <span class="keyword">if</span> ReadBit(r,site) ^ ReadBit(r,(site+<span class="number">1</span>) % N):</span><br><span class="line">            cnt += -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    Hr[r] = -J * cnt</span><br><span class="line">    res = np.zeros(n,dtype=<span class="built_in">complex</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        res += Hr[i] * P[i]                         <span class="comment"># P[i] 是初始化存储好的 P_k 算符作用结果，方便 O(1)查找节省时间</span></span><br><span class="line">    <span class="keyword">return</span> res      </span><br></pre></td></tr></table></figure>
<ul>
<li><p>下面的 H dis_k 是按照 $k$ 分类来存储块哈密顿矩阵</p>
</li>
<li><p>$\mathrm{R} $ 存储满足 $T^R|r\rangle=|r\rangle$ 的步数，方面后面寻找满足 $k R=$ integer $\cdot N$ 的 $k$</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculation</span>(<span class="params">N,g</span>):   </span><br><span class="line">    n = <span class="number">1</span>&lt;&lt;N</span><br><span class="line">    <span class="comment">#print(&quot;g=&quot;+str(g))</span></span><br><span class="line">    H_dis_k = []</span><br><span class="line">    R = np.zeros(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (T(i,k,N) != i):</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        R[i] = k</span><br><span class="line">    <span class="comment">#list 存储“代表性基矢”</span></span><br><span class="line">    <span class="built_in">list</span> = []</span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        inistate = Findmin(state,N)</span><br><span class="line">        <span class="keyword">if</span> (inistate == state):</span><br><span class="line">            <span class="built_in">list</span>.append(state)</span><br><span class="line">    <span class="comment">#Pr 按 k 分类来投影基矢 Pk|r&gt;</span></span><br><span class="line">    Pr = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">            <span class="keyword">if</span> (k*R[state]) % N == <span class="number">0</span>:</span><br><span class="line">                Pr[k].append(state)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        s = <span class="built_in">len</span>(Pr[k])                                  <span class="comment">#s是Pr[k]基矢个数，即 k 对应的子矩阵大小</span></span><br><span class="line">        M = np.zeros([s,s],dtype = <span class="built_in">complex</span>)             <span class="comment">#M 存储当前 k 值下的子矩阵</span></span><br><span class="line">        P = np.zeros([n,n],dtype = <span class="built_in">complex</span>)             <span class="comment">#P 存储的 P_k 算符作用结果，方便 O(1)查找节省时间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            P[i] = Pk(i,k,N)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s):      </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(s):                          <span class="comment">#按照前面推导结果求 M[j][i]</span></span><br><span class="line">                r = Pr[k][i]</span><br><span class="line">                rr = Pr[k][j]</span><br><span class="line">                M[j][i] = PkH(r,k,P,g,N)[rr] / np.sqrt(P[r][r] * P[rr][rr])</span><br><span class="line">        E,W = np.linalg.eigh(M)</span><br><span class="line">        <span class="comment">#print(&quot;k=&quot;+str(k))</span></span><br><span class="line">        <span class="comment">#print(np.real(np.round(E,5)),sep=&quot;,&quot;)</span></span><br><span class="line">        H_dis_k.append(E)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#绘制色散关系 E(k)</span></span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(H_dis_k[k])):</span><br><span class="line">            x.append(k)</span><br><span class="line">            y.append(H_dis_k[k][i])</span><br><span class="line">    plt.xlabel(<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;g=&quot;</span>+<span class="built_in">str</span>(g)+<span class="string">&quot;  E(k)&quot;</span>)</span><br><span class="line">    plt.scatter(x, y, <span class="number">3</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;N_&quot;</span>+<span class="built_in">str</span>(N)+<span class="string">&quot;_g_&quot;</span>+<span class="built_in">str</span>(g)+<span class="string">&quot;.png&quot;</span>)</span><br><span class="line">    plt.clf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H_dis_k</span><br></pre></td></tr></table></figure>
<ul>
<li>对于第一问，N=8，分别计算g=1.7和0.7，得到结果如下（print函数费时，该代码块运行一次大概15s）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">E1 = calculation(<span class="number">8</span>,<span class="number">1.7</span>)</span><br><span class="line">E2 = calculation(<span class="number">8</span>,<span class="number">0.7</span>)</span><br><span class="line">N = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;g=&quot;</span>+<span class="built_in">str</span>(<span class="number">1.7</span>))</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;k=&quot;</span>+<span class="built_in">str</span>(k))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> E1[k]:</span><br><span class="line">        <span class="built_in">print</span>(np.real(np.<span class="built_in">round</span>(item,<span class="number">5</span>)),sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;g=&quot;</span>+<span class="built_in">str</span>(<span class="number">0.7</span>))</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;k=&quot;</span>+<span class="built_in">str</span>(k))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> E2[k]:</span><br><span class="line">        <span class="built_in">print</span>(np.real(np.<span class="built_in">round</span>(item,<span class="number">5</span>)),sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>N = 8 时， k 所对应的本征值比较多:</p>
</li>
<li><p>色散关系图如下图所示（pltshow的图片没有坐标，截图放在目录下pic文件夹下）：</p>
</li>
</ul>
<div  align="center">    
<img src=https://s2.loli.net/2022/10/18/YPxIZAcEedmhp1q.png style="zoom:70%" />  
<img src=https://s2.loli.net/2022/10/18/t516zUgqC7lcVT9.png style="zoom:70%" />
</div>


<ul>
<li>对于第二问，Transverse field Ising model 是有 Exact Solution 的，具体推导见 PPT，这里简单梳理一下：</li>
</ul>
<ul>
<li><p>Step 1: Jordan-Wigner transformation</p>
<p>  1/2 自旋子和无自旋费米子之间映射：$\sigma_i^z=-\prod_{j=1}^{i-1}\left(1-2 C_j^{\dagger} C_j\right)\left(C_i+C_i^{\dagger}\right), \quad \sigma_i^x=1-2 C_i^{\dagger} C_i$</p>
<script type="math/tex; mode=display">
  \begin{aligned}
  H &=-J \sum_{i=1}^N\left(g \sigma_i^x+\sigma_i^z \sigma_{i+1}^z\right) \\
  &=-J \sum_{i=1}^N g\left(1-2 C_i^{\dagger} C_i\right)-J \sum_{i=1}^{N-1}\left(C_i^{\dagger}-C_i\right)\left(C_{i+1}+C_{i+1}^{\dagger}\right)+J P\left(C_N^{\dagger}-C_N\right)\left(C_1+C_1^{\dagger}\right)
  \end{aligned}</script></li>
</ul>
<p>where $\quad P=\prod_{i=1}^N \sigma_i^x=\prod_{j=1}^N\left(1-2 C_j^{\dagger} C_j\right)=\exp (i \pi M), \quad M=\sum_{i=1}^N C_i^{\dagger} C_i$</p>
<ul>
<li><p>Step 2: Fourier transformation</p>
<script type="math/tex; mode=display">
  C_k=\frac{1}{\sqrt{N}} \sum_{j=1}^N C_j \exp (-i k j), \quad k=2 \pi n / N</script><script type="math/tex; mode=display">
  H=J \sum_k\left[2(g-\cos k) C_k^{\dagger} C_k+i \sin k\left(C_{-k}^{\dagger} C_k^{\dagger}+C_{-k} C_k\right)-g\right]</script></li>
<li><p>Step 3: Bogliubov transformation</p>
<p>  we introduce</p>
<script type="math/tex; mode=display">
  \begin{array}{ll}
  C_k=u_k \gamma_k+i v_k \gamma_{-k}^{\dagger}, & C_{-k}=u_k \gamma_{-k}-i v_k \gamma_k^{\dagger} \\
  C_k^{\dagger}=u_k \gamma_k^{\dagger}-i v_k \gamma_{-k}, & C_{-k}^{\dagger}=u_k \gamma_{-k}^{\dagger}+i v_k \gamma_k
  \end{array}</script><p>  where $u_k, v_k$ are real numbers, satisfying</p>
<script type="math/tex; mode=display">
  u_k^2+v_k^2=1, \quad u_{-k}=u_k, \quad v_{-k}=-v_k</script></li>
<li><p>Step 4: final step</p>
<p>  we choose</p>
<script type="math/tex; mode=display">
  u_k=\cos \left(\frac{\theta_k}{2}\right), \quad v_k=\sin \left(\frac{\theta_k}{2}\right), \quad \tan \theta_k=\frac{\sin k}{g-\cos k}</script><p>  we finally have</p>
<script type="math/tex; mode=display">
  \begin{aligned}
  H &=2 J \sum_k \sqrt{1+g^2-2 g \cos k}\left(\gamma_k^{\dagger} \gamma_k-\frac{1}{2}\right) \\
  &=2 J \sum_k \sqrt{1+g^2-2 g \cos k} \gamma_k^{\dagger} \gamma_k-J \sum_k \sqrt{1+g^2-2 g \cos k}=\sum_k \epsilon_k \gamma_k^{\dagger} \gamma_k-\epsilon_0
  \end{aligned}</script></li>
</ul>
<ul>
<li>我们可以根据最后结果 $\sum_k \epsilon_k \gamma_k^{\dagger} \gamma_k-\epsilon_0$ 求精确解，来和前面的做法作比较。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Exact Solution for g &gt; 1 (g=1.7)</span></span><br><span class="line">N =<span class="number">6</span></span><br><span class="line">g =<span class="number">1.7</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line">result = []                                             <span class="comment">#存最后结果</span></span><br><span class="line">K_even = []                                             </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):                                      <span class="comment">#偶数：n是半整数</span></span><br><span class="line">    k = (<span class="number">2</span> * PI / N) * (-N/<span class="number">2</span> + <span class="number">0.5</span> + i)</span><br><span class="line">    eg = <span class="number">2</span> * np.sqrt(<span class="number">1</span> + g*g -<span class="number">2</span>*g*np.cos(k))</span><br><span class="line">    K_even.append(eg)</span><br><span class="line">eg0 = np.<span class="built_in">sum</span>(K_even) / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> Num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N+<span class="number">1</span>,<span class="number">2</span>):                              <span class="comment">#选取偶数个</span></span><br><span class="line">    selection = combinations(K_even,Num)                <span class="comment">#K_even 中选 Num 个</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> selection:</span><br><span class="line">        result.append(np.<span class="built_in">sum</span>(item) - eg0)</span><br><span class="line">K_odd = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):                                      <span class="comment">#奇数：n是整数</span></span><br><span class="line">    k = (<span class="number">2</span> * PI / N) * (-N/<span class="number">2</span> + i )</span><br><span class="line">    eg = <span class="number">2</span> * np.sqrt(<span class="number">1</span> + g*g -<span class="number">2</span>*g*np.cos(k))</span><br><span class="line">    K_odd.append(eg)</span><br><span class="line">eg0 = (np.<span class="built_in">sum</span>(K_odd) ) / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> Num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N,<span class="number">2</span>):                                <span class="comment">#选取奇数个</span></span><br><span class="line">    selection = combinations(K_odd,Num)                 <span class="comment">#K_odd 中选 Num 个</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> selection:</span><br><span class="line">        result.append(np.<span class="built_in">sum</span>(item) - eg0)</span><br><span class="line">result.sort()                                           <span class="comment">#排序方便比较</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(result,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[-11.11794  -9.68837  -8.12864  -8.12864  -7.22844  -6.35973  -6.35973
  -5.68837  -5.22857  -5.22857  -5.22857  -5.22857  -3.94462  -3.94462
  -3.94462  -3.94462  -3.76891  -3.2287   -2.       -2.       -2.
  -2.       -1.94475  -1.94475  -1.94475  -1.94475  -1.32864  -1.32864
  -0.6608   -0.44027  -0.44027  -0.23109   0.23109   0.44027   0.44027
   0.6608    1.32864   1.32864   1.94475   1.94475   1.94475   1.94475
   2.        2.        2.        2.        3.2287    3.76891   3.94462
   3.94462   3.94462   3.94462   5.22857   5.22857   5.22857   5.22857
   5.68837   6.35973   6.35973   7.22844   8.12864   8.12864   9.68837
  11.11794]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Exact Solution for g &lt; 1 (g=0.7)</span></span><br><span class="line">N = <span class="number">6</span></span><br><span class="line">g = <span class="number">0.7</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line">result = []                                             <span class="comment">#存最后结果</span></span><br><span class="line">K_even = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    k = (<span class="number">2</span> * PI / N) * (-N/<span class="number">2</span> + <span class="number">0.5</span> + i)                 <span class="comment">#偶数：n是半整数</span></span><br><span class="line">    eg = <span class="number">2</span> * np.sqrt(<span class="number">1</span> + g*g -<span class="number">2</span>*g*np.cos(k))</span><br><span class="line">    K_even.append(eg)</span><br><span class="line">eg0 = np.<span class="built_in">sum</span>(K_even) / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> Num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N+<span class="number">1</span>,<span class="number">2</span>):                              <span class="comment">#选取偶数个</span></span><br><span class="line">    selection = combinations(K_even,Num)                <span class="comment">#K_even 中选 Num 个</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> selection:</span><br><span class="line">        result.append(np.<span class="built_in">sum</span>(item) - eg0)</span><br><span class="line">K_odd = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):                                      <span class="comment">#奇数：n是整数</span></span><br><span class="line">    k = (<span class="number">2</span> * PI / N) * (-N/<span class="number">2</span> + i )</span><br><span class="line">    eg = <span class="number">2</span> * np.sqrt(<span class="number">1</span> + g*g -<span class="number">2</span>*g*np.cos(k))</span><br><span class="line">    K_odd.append(eg)</span><br><span class="line">eg0 = (np.<span class="built_in">sum</span>(K_odd) ) / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> Num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N+<span class="number">1</span>,<span class="number">2</span>):                              <span class="comment">#不一样的地方：g&lt;1时选取偶数个</span></span><br><span class="line">    selection = combinations(K_odd,Num)                 <span class="comment">#K_odd 中选 Num 个</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> selection:</span><br><span class="line">        result.append(np.<span class="built_in">sum</span>(item) - eg0)</span><br><span class="line">result.sort()                                           <span class="comment">#排序方便比较</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(result,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[-6.78282 -6.73737 -4.67544 -4.35973 -4.35973 -3.28782 -3.28782 -3.28782
 -3.28782 -3.18209 -3.17764 -3.17764 -2.73737 -2.44131 -2.44131 -2.44131
 -2.44131 -2.      -2.      -2.      -2.      -1.90019 -1.55973 -1.55973
 -1.05369 -1.05369 -1.05369 -1.05369 -0.81791 -0.37764 -0.37764 -0.20718
  0.20718  0.37764  0.37764  0.81791  1.05369  1.05369  1.05369  1.05369
  1.55973  1.55973  1.90019  2.       2.       2.       2.       2.44131
  2.44131  2.44131  2.44131  2.73737  3.17764  3.17764  3.18209  3.28782
  3.28782  3.28782  3.28782  4.35973  4.35973  4.67544  6.73737  6.78282]
</code></pre><ul>
<li>我们用 calculation 计算 N = 6 时 g = 1.7 和 g = 0.7 分别对应的本征值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">E1 = calculation(<span class="number">6</span>,<span class="number">1.7</span>)</span><br><span class="line">E2 = calculation(<span class="number">6</span>,<span class="number">0.7</span>)</span><br><span class="line">Ans1 = []</span><br><span class="line">Ans2 = []</span><br><span class="line">N = <span class="number">6</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> E1[k]:</span><br><span class="line">        Ans1.append(np.real(np.<span class="built_in">round</span>(item,<span class="number">5</span>)))</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> E2[k]:</span><br><span class="line">        Ans2.append(np.real(np.<span class="built_in">round</span>(item,<span class="number">5</span>)))</span><br><span class="line">Ans1.sort()</span><br><span class="line">Ans2.sort()</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(Ans1,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(Ans2,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[-11.11794  -9.68837  -8.12864  -8.12864  -7.22844  -6.35973  -6.35973
  -5.68837  -5.22857  -5.22857  -5.22857  -5.22857  -3.94462  -3.94462
  -3.94462  -3.94462  -3.76891  -3.2287   -2.       -2.       -2.
  -2.       -1.94475  -1.94475  -1.94475  -1.94475  -1.32864  -1.32864
  -0.6608   -0.44027  -0.44027  -0.23109   0.23109   0.44027   0.44027
   0.6608    1.32864   1.32864   1.94475   1.94475   1.94475   1.94475
   2.        2.        2.        2.        3.2287    3.76891   3.94462
   3.94462   3.94462   3.94462   5.22857   5.22857   5.22857   5.22857
   5.68837   6.35973   6.35973   7.22844   8.12864   8.12864   9.68837
  11.11794]

[-6.78282 -6.73737 -4.67544 -4.35973 -4.35973 -3.28782 -3.28782 -3.28782
 -3.28782 -3.18209 -3.17764 -3.17764 -2.73737 -2.44131 -2.44131 -2.44131
 -2.44131 -2.      -2.      -2.      -2.      -1.90019 -1.55973 -1.55973
 -1.05369 -1.05369 -1.05369 -1.05369 -0.81791 -0.37764 -0.37764 -0.20718
  0.20718  0.37764  0.37764  0.81791  1.05369  1.05369  1.05369  1.05369
  1.55973  1.55973  1.90019  2.       2.       2.       2.       2.44131
  2.44131  2.44131  2.44131  2.73737  3.17764  3.17764  3.18209  3.28782
  3.28782  3.28782  3.28782  4.35973  4.35973  4.67544  6.73737  6.78282]



&lt;Figure size 432x288 with 0 Axes&gt;
</code></pre><ul>
<li>为方便比较，都进行了排序，可以直观地发现 ED 得到的本征值和精确解一致。</li>
</ul>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Exact diagonalization -- Hubbard model</title>
    <url>/2022/10/08/HW_task1_hubbard_with_U1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size=5>Homework (task 1)</font>

<ul>
<li>write a code for diagonalizing the extended Hubbard model on a 6-site ladder</li>
</ul>

$$
H=-t \sum_{\{i, j\}, \sigma}\left(C_{i, \sigma}^{\dagger} C_{j, \sigma}+C_{j, \sigma}^{\dagger} C_{i, \sigma}\right)+U \sum_i n_{i \uparrow} n_{i \downarrow}-V \sum_{\{\{i, j\}\}}\left(n_{i, \uparrow}+n_{i, \downarrow}\right)\left(n_{j, \uparrow}+n_{j, \downarrow}\right)-\mu \sum_{i, \sigma} n_{i, \sigma}
$$

$$
\begin{aligned}
&\{i, j\} \in(0,1),(1,2),(3,4),(4,5),(1,3),(2,4) \\
&\{\{i, j\}\} \in(0,3),(1,4),(2,5),(2,3)
\end{aligned}
$$

<ul>
<li>take t = 1.0, U = 1.4, V = 0.3, 𝜇 = 0.1</li>
</ul>
<p>(1) show the lowest 20 eigenvalues. please make use of the U(1) symmetry</p>
<p>(2) calculate $\left\langle n_{i, \sigma}\right\rangle$ for each site and spin using the ground state</p>
<ul>
<li><p>简单思路分析：</p>
<ol>
<li><p>六个site，考虑spin的up和down，则可以用一个12位的二进制数表示一个态。规则如下：</p>
<p> | xxxxxx xxxxxx &gt; : 左边表示自旋朝下，右边表示自旋朝上，每部分从右往左分别编号为 0，1…,5</p>
<p> 例如 ： | 000010 000001 &gt; 表示在 0 site 有一个$\uparrow$，在 1 site 有一个$\downarrow$, 其他位置为空</p>
</li>
<li><p>哈密顿量分为对角项（u，v，𝜇）和非对角项（t）：</p>
<p> 对于前者比较简单，只需要按照规则进行位操作即可；</p>
<p> 后者考虑U(1)对称，即粒子数守恒或自旋守恒，这里我们把问题简单化，考虑粒子数守恒，即非对角项只出现粒子数不改变的两个态之间，我们只需要按照粒子数做分类并编号，然后在各自的 space 中去 check 能否 hopping，并计算系数即可。</p>
<p> 具体见代码。</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LA</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数定义</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">1.0</span></span><br><span class="line">U = <span class="number">1.4</span></span><br><span class="line">V = <span class="number">0.3</span></span><br><span class="line">miu = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#N is the number of sites, and n is the number of states</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">6</span></span><br><span class="line">n = <span class="number">1</span>&lt;&lt;<span class="number">2</span>*N</span><br><span class="line"></span><br><span class="line"><span class="comment">#最近邻作用和次近邻作用对，方便遍历</span></span><br><span class="line">First_Near = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">1</span>),(<span class="number">4</span>,<span class="number">2</span>)]</span><br><span class="line">Second_Near = [(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一些位操作运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReadBit</span>(<span class="params">i,n</span>):                           <span class="comment">#读取i的第n位</span></span><br><span class="line">    <span class="keyword">return</span> (i&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PopCntBit</span>(<span class="params">i</span>):                           <span class="comment">#计数i态有多少个&quot;1&quot;(自旋个数)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(i).count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SetBit</span>(<span class="params">i,n</span>):                            <span class="comment">#i的第n位设置为&quot;1&quot;</span></span><br><span class="line">    <span class="keyword">return</span> i|(<span class="number">1</span>&lt;&lt;n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ClearBit</span>(<span class="params">i,n</span>):                          <span class="comment">#i的第n位设置为&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> i&amp;~(<span class="number">1</span>&lt;&lt;n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PickBit</span>(<span class="params">i,k,n</span>):                         <span class="comment">#从第k位向左走n位 这部分取出来</span></span><br><span class="line">    <span class="keyword">return</span> (i&amp;((<span class="number">2</span>**n-<span class="number">1</span>)&lt;&lt;k))&gt;&gt;k</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#哈密顿量的第二三四项（对角项），不用考虑态的变化，只需要按照给定的H计算前面的系数即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">U_func</span>(<span class="params">state</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        res += ReadBit(state,i) &amp; ReadBit(state,i+N)</span><br><span class="line">    <span class="keyword">return</span> res * U</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">V_func</span>(<span class="params">state</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i,j) <span class="keyword">in</span> Second_Near:</span><br><span class="line">        res += (ReadBit(state,i) + ReadBit(state,i+<span class="number">6</span>)) * (ReadBit(state,j) + ReadBit(state,j+<span class="number">6</span>))</span><br><span class="line">    <span class="keyword">return</span> res * V</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">miu_func</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> PopCntBit(state) * miu</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义产生湮灭算符规则 C(state, site, spin, op)： </span></span><br><span class="line"><span class="comment">#Input: state 为作用的态， site 为位点（0~5），spin为自旋（-0.5/0.5），op为产生or湮灭(1 or 0)</span></span><br><span class="line"><span class="comment">#Output: flag 表示是否存在输出的态(1/0), resstate 表示C算符作用后得到的（不考虑正负的）态， pm为C算符作用后态的正负号（1/-1）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">C</span>(<span class="params">state, site, spin, op</span>):</span><br><span class="line">    resstate = <span class="number">0</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    pm = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> op <span class="keyword">and</span> spin &gt; <span class="number">0</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> ReadBit(state,site) == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        resstate = SetBit(state,site) <span class="keyword">if</span> flag <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            pm = -<span class="number">1</span> <span class="keyword">if</span> PopCntBit(PickBit(state,<span class="number">0</span>,site)) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> op <span class="keyword">and</span> spin &lt; <span class="number">0</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> ReadBit(state,site+N) == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        resstate = SetBit(state,site+N) <span class="keyword">if</span> flag <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            pm = -<span class="number">1</span> <span class="keyword">if</span> PopCntBit(PickBit(state,<span class="number">0</span>,site+N)) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> op <span class="keyword">and</span> spin &gt; <span class="number">0</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> ReadBit(state,site) == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        resstate = ClearBit(state,site) <span class="keyword">if</span> flag <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            pm = -<span class="number">1</span> <span class="keyword">if</span> PopCntBit(PickBit(state,<span class="number">0</span>,site)) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> op <span class="keyword">and</span> spin &lt; <span class="number">0</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> ReadBit(state,site+N) == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        resstate = ClearBit(state,site+N) <span class="keyword">if</span> flag <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            pm = -<span class="number">1</span> <span class="keyword">if</span> PopCntBit(PickBit(state,<span class="number">0</span>,site+N)) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> flag,resstate,pm</span><br></pre></td></tr></table></figure>
<ul>
<li>对于非对角hopping项，我们简单说明一下思路。</li>
</ul>
<ol>
<li>直接地，若不考虑symm，我们枚举所有的态，对每一态在 First_Near 限制下枚举产生湮灭算符作用后得到的态，然后去检查这两个态之间的转化能否成立。伪代码如下注释：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不考虑U(1)全遍历，作为伪代码注释放在这里</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">H = np.zeros([n,n])</span></span><br><span class="line"><span class="string"># H 的第二三四项(对角项)计算</span></span><br><span class="line"><span class="string">for i in range(n):</span></span><br><span class="line"><span class="string">    H[i,i] += U_func(i)</span></span><br><span class="line"><span class="string">    H[i,i] -= V_func(i)</span></span><br><span class="line"><span class="string">    H[i,i] -= miu_func(i)</span></span><br><span class="line"><span class="string"># H 的第一项(非对角项)计算</span></span><br><span class="line"><span class="string">for a in range(n):</span></span><br><span class="line"><span class="string">    for (i,j) in First_Near:</span></span><br><span class="line"><span class="string">        for spin in [-0.5,0.5]:</span></span><br><span class="line"><span class="string">            a1flag, a1, a1pm = C(a,j,spin,0)</span></span><br><span class="line"><span class="string">            if a1flag:</span></span><br><span class="line"><span class="string">                bflag, b, bpm = C(a1,i,spin,1)</span></span><br><span class="line"><span class="string">                if bflag:</span></span><br><span class="line"><span class="string">                    H[b,a] = -t * a1pm * bpm</span></span><br><span class="line"><span class="string">            a1flag, a1, a1pm = C(a,i,spin,0)</span></span><br><span class="line"><span class="string">            if a1flag:</span></span><br><span class="line"><span class="string">                bflag, b, bpm = C(a1,j,spin,1)</span></span><br><span class="line"><span class="string">                if bflag:</span></span><br><span class="line"><span class="string">                    H[b,a] = -t * a1pm * bpm</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>显然我们这样做是浪费了一些搜索空间和时间的，因为没有考虑物理约束，即 hopping 过程中自旋数不会发生改变。基于这种对称性，我们可以重新对基矢进行排序，或者说将 4096 * 4096 的空间划分为 13 个子空间，分类的依据是自旋个数 n， n = 0,1,…12. </p>
<p> 值得一提的是， 前面不考虑 U(1) 中的基矢顺序就是态对应的十进制数，但是在考虑 U(1) 中的基矢顺序是按照 subspace 来排序的， 这样子哈密顿量 $<br>\mathrm{H}=\mathrm{H}_0 \oplus \cdots \oplus \mathrm{H}_n \oplus \cdots \oplus \mathrm{H}_N<br>$ 直和的形式。</p>
<p> 代码如下：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建一个字典数组 DictFind[i], i代表第i个子空间， 字典内存储的&lt;key,value&gt;对是&lt;态,编号&gt;</span></span><br><span class="line">DictFind = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#预处理构建 DictFind </span></span><br><span class="line">count = np.zeros(<span class="number">2</span>*N+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    count[PopCntBit(i)] += <span class="number">1</span> </span><br><span class="line">    DictFind[PopCntBit(i)][i] = count[PopCntBit(i)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#space数组最开始是存放每个subspace的大小，然后为了后面直和操作方便，重定义为subspace大小的累加，即 space(i) += space(i-1)</span></span><br><span class="line">space = np.zeros(<span class="number">2</span>*N+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*N+<span class="number">1</span>):</span><br><span class="line">    space[i] = <span class="built_in">len</span>(DictFind[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>*N+<span class="number">1</span>):</span><br><span class="line">    space[i] = space[i] + space[i-<span class="number">1</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment">#HH 即基于上述规则构建的哈密顿量，我们只需要在每个子空间内check hopping，由于已经建好了Dict，我们的查找是O(1)的</span></span><br><span class="line">HH = np.zeros([n,n])    </span><br><span class="line"><span class="keyword">for</span> SpinNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> state,index <span class="keyword">in</span> DictFind[SpinNum].items():</span><br><span class="line">        <span class="keyword">for</span> (i,j) <span class="keyword">in</span> First_Near:</span><br><span class="line">            <span class="keyword">for</span> spin <span class="keyword">in</span> [-<span class="number">0.5</span>,<span class="number">0.5</span>]:</span><br><span class="line">                flag1, state1, pm1 = C(state, j, spin, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> flag1:</span><br><span class="line">                    flag2, state2,pm2 = C(state1, i, spin, <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> flag2:</span><br><span class="line">                        HH[<span class="built_in">int</span>(space[SpinNum-<span class="number">1</span>]+index-<span class="number">1</span>) , <span class="built_in">int</span>(space[SpinNum-<span class="number">1</span>]+DictFind[SpinNum].get(state2)-<span class="number">1</span>)] = -t * pm1 *pm2 <span class="comment"># - 1 for pos adjustion</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#H的对角项</span></span><br><span class="line"><span class="keyword">for</span> SpinNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , <span class="number">2</span>*N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> state,index <span class="keyword">in</span> DictFind[SpinNum].items():</span><br><span class="line">        pos = <span class="built_in">int</span>(space[SpinNum-<span class="number">1</span>] + index - <span class="number">1</span>)</span><br><span class="line">        HH[pos,pos] += U_func(state)</span><br><span class="line">        HH[pos,pos] -= V_func(state)</span><br><span class="line">        HH[pos,pos] -= miu_func(state)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li>完成 H 后用 scipy.sparse.linalg.eigsh 计算前20个本征值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># E : eigenvalue; W : eigenstate</span></span><br><span class="line">E,W = LA.eigsh(HH,<span class="number">20</span>,which = <span class="string">&#x27;SA&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(E)</span><br></pre></td></tr></table></figure>
<pre><code>[-6.72233554 -6.72233554 -6.72233554 -6.66948732 -6.66948732 -6.48366037
 -6.44217804 -6.42461287 -6.3983409  -6.3983409  -6.35051543 -6.35051543
 -6.20881398 -6.20881398 -6.05241516 -6.05241516 -6.05241516 -5.95813498
 -5.95813498 -5.94631099]
</code></pre><ul>
<li><p>得到结果如下：</p>
<p>  [-6.72233554 -6.72233554 -6.72233554 -6.66948732 -6.66948732 </p>
<p>  -6.48366037 -6.44217804 -6.42461287 -6.3983409  -6.3983409 </p>
<p>  -6.35051543 -6.35051543 -6.20881398 -6.20881398 -6.05241516 </p>
<p>  -6.05241516 -6.05241516 -5.95813498 -5.95813498 -5.94631099]</p>
<ul>
<li>可以看到，基态能量约为 -6.7223， 三重简并。这是符合我们预期的，对于这样一个6-sites存在旋转对称作用的体系。接下来我们计算一下 $\left\langle n_{i, \sigma}\right\rangle$</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由于三重简并，用n_bar_i，i=1，2，3分别存储三个本征矢量表象下的 &lt;n&gt;，数组顺序为从低位到高位(从右往左)</span></span><br><span class="line">n_bar_1 = np.zeros(<span class="number">2</span>*N)</span><br><span class="line">n_bar_2 = np.zeros(<span class="number">2</span>*N)</span><br><span class="line">n_bar_3 = np.zeros(<span class="number">2</span>*N)</span><br><span class="line"><span class="keyword">for</span> SpinNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , <span class="number">2</span>*N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> state,index <span class="keyword">in</span> DictFind[SpinNum].items():</span><br><span class="line">        pos = <span class="built_in">int</span>(space[SpinNum-<span class="number">1</span>] + index - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*N):</span><br><span class="line">            <span class="keyword">if</span> ReadBit(state,i):</span><br><span class="line">                n_bar_1[i] += np.power(W[:,<span class="number">0</span>][pos],<span class="number">2</span>)</span><br><span class="line">                n_bar_2[i] += np.power(W[:,<span class="number">1</span>][pos],<span class="number">2</span>)</span><br><span class="line">                n_bar_3[i] += np.power(W[:,<span class="number">2</span>][pos],<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(n_bar_1)</span><br><span class="line"><span class="built_in">print</span>(n_bar_2)</span><br><span class="line"><span class="built_in">print</span>(n_bar_3)</span><br><span class="line"></span><br><span class="line"><span class="comment">#n_bar 为上述三组值的平均值</span></span><br><span class="line">n_bar = np.zeros(<span class="number">2</span>*N)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*N):</span><br><span class="line">    n_bar[i] = (n_bar_1[i]+n_bar_2[i]+n_bar_3[i])/<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(n_bar)</span><br></pre></td></tr></table></figure>
<pre><code>[0.30471289 0.53758844 0.25223012 0.25223012 0.53758844 0.30471289
 0.68664588 0.43919814 0.77962453 0.77962453 0.43919814 0.68664588]
[0.50412966 0.4862164  0.52759594 0.52759594 0.4862164  0.50412966
 0.48722911 0.49057018 0.50425871 0.50425871 0.49057018 0.48722911]
[0.6781956  0.44137503 0.76795591 0.76795591 0.44137503 0.6781956
 0.31316317 0.53541155 0.26389874 0.26389874 0.53541155 0.31316317]
[0.49567939 0.48839329 0.51592732 0.51592732 0.48839329 0.49567939
 0.49567939 0.48839329 0.51592732 0.51592732 0.48839329 0.49567939]
</code></pre><ul>
<li><p>由于三重简并，我们 n_bar_i，i=1，2，3 分别存储三个本征矢量表象下的 $\left\langle n_{i, \sigma}\right\rangle$，数组顺序为从低位到高位(从右往左)</p>
</li>
<li><p>我们发现每次运行的结果都不一样，这是因为 scipy 的 eigsh 函数的内置算法随机性导致的，每次计算的本征矢量都有所不同，这里我们取了其中一次的计算结果放在这里：</p>
</li>
</ul>
<pre><code>1. [0.32422012 0.53256315 0.2791668  0.2791668  0.53256315 0.32422012

    0.66713865 0.44422343 0.75268785 0.75268785 0.44422343 0.66713865]

2. [0.69565789 0.43687655 0.79206881 0.79206881 0.43687655 0.69565789

    0.29570088 0.53991004 0.23978584 0.23978584 0.53991004 0.29570088]

3. [0.46716014 0.49574017 0.47654636 0.47654636 0.49574017 0.46716014

    0.52419863 0.48104641 0.55530828 0.55530828 0.48104641 0.52419863]
</code></pre><ul>
<li><p>每个数组有 12 个元素，依次表示 : (0,$\uparrow$) , (1,$\uparrow$) , … , (5,$\uparrow$) , (0,$\downarrow$) , … , (5,$\downarrow$) 的 $\left\langle n_{i, \sigma}\right\rangle$</p>
</li>
<li><p>尽管如此，我们可以对对应构型的 <n> 取平均，发现得到的 $(n_{bar1} + n_{bar2} +n_{bar3}) / 3$ 如下：</p>
<ul>
<li><p>[0.49567939 0.48839329 0.51592732 0.51592732 0.48839329 0.49567939</p>
<p>  0.49567939 0.48839329 0.51592732 0.51592732 0.48839329 0.49567939]</p>
</li>
</ul>
</li>
<li><p>可见对任意的 $i$ 和 $\sigma$, $\left\langle n_{i, \sigma}\right\rangle$ 的期望都约为 $1/2$。 在基态的表象下，各位点的占据数趋于半满。</p>
</li>
</ul>
<font size=5>Reference </font>

<ol>
<li>Lin, H. Q. “Exact diagonalization of quantum-spin models.” Physical Review B 42.10 (1990): 6561.</li>
</ol>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Time evolution of s single-particle GWP</title>
    <url>/2022/10/09/HW_task2_time%20evolution/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size=5>Homework (task 2)</font>

<ul>
<li>consider the time evolution of a single-particle Gaussian wave packet on<br>a tight-binding chain with a gradient field: <script type="math/tex; mode=display">
\begin{gathered}
H=-\sum_{j=1}^{N-1}(|j\rangle\langle j+1|+| j+1\rangle\langle j|)+F \sum_{j=1}^N j|j\rangle\langle j| \\
|\psi(t=0)\rangle=\frac{1}{\sqrt{\Omega}} \sum_j e^{-\left(\alpha^2 / 2\right)\left(j-N_0\right)^2} e^{i k_0 j}|j\rangle
\end{gathered}</script></li>
<li><p>we choose $N=101, F=0.1, k_0=\pi / 2, \alpha=0.15, N_0=51, t \in[0,100]$ </p>
<p>  please plot $|\psi(j, t)|^2$ as functions of $j$ and $t$</p>
<p>  you will observe an oscillation behavior, that is Bloch oscillation</p>
<p>  which describes the oscillation of a particle confined in a periodic potential when a constant force is acting on it</p>
<p>  you may also try other parameters for fun</p>
</li>
<li><p>思路与代码实现：</p>
<ol>
<li>调用计算和绘图所需要的库，定义参数。对于给出的哈密顿量做 ED， 得到本征值 $E_{n}$ 和本征态 $\psi_{n}$</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LA</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">N = <span class="number">101</span></span><br><span class="line"><span class="comment">#F = 1.0</span></span><br><span class="line">F = <span class="number">0.1</span></span><br><span class="line"><span class="comment">#k0 = 0</span></span><br><span class="line">k0 = np.pi/<span class="number">2</span></span><br><span class="line">alpha = <span class="number">0.15</span></span><br><span class="line">N0 = <span class="number">51</span></span><br><span class="line"></span><br><span class="line">H = np.zeros([N,N])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    H[i][i] = F * (i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>):</span><br><span class="line">    H[i][i+<span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line">    H[i+<span class="number">1</span>][i] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">E,V = np.linalg.eigh(H)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>对于初始时刻，波函数公式如下，我们用 Psi0 数组存储，可见其是在 $|j\rangle$ 表象下。</li>
</ol>
</li>
</ul>
<script type="math/tex; mode=display">
|\psi(t=0)\rangle=\frac{1}{\sqrt{\Omega}} \sum_j e^{-\left(\alpha^2 / 2\right)\left(j-N_0\right)^2} e^{i k_0 j}|j\rangle</script><p>​    其中 $\Omega$ 是：</p>
<script type="math/tex; mode=display">
\Omega=\sum_j \exp \left[-\alpha^2\left(j-N_0\right)^2\right]</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按照定义得到初始时刻的Gaussian wave packet </span></span><br><span class="line">Omega = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">    Omega += np.exp(-np.power(alpha,<span class="number">2</span>) * np.power(i - N0,<span class="number">2</span>)) </span><br><span class="line">Psi0 = np.zeros(N , dtype = <span class="built_in">complex</span>)                 </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">    Psi0[i-<span class="number">1</span>] = np.exp(- np.power(alpha,<span class="number">2</span>) / <span class="number">2</span> * np.power(i - N0,<span class="number">2</span>)) * np.exp(k0 * i * <span class="number">1.0j</span>) / np.sqrt(Omega)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>进行含时演化，我们知道含时的薛定谔方程：<script type="math/tex; mode=display">
i \hbar \frac{\partial}{\partial t}|\psi(t)\rangle=H|\psi(t)\rangle</script></li>
</ol>
</li>
</ul>
<p>​    我们已经有了初始的 $\psi(0)$, 以及本征值 $E_{n}$ 和本征态 $\psi_{n}$，那么：</p>
<script type="math/tex; mode=display">
|\psi(t)\rangle=e^{-i H t / \hbar}|\psi(0)\rangle=\sum_n e^{-i E_n t / \hbar}\left|\psi_n\right\rangle\left\langle\psi_n \mid \psi(0)\right\rangle=\sum_n C_n e^{-i E_n t / \hbar}\left|\psi_n\right\rangle</script><script type="math/tex; mode=display">
C_n=\left\langle\psi_n \mid \psi(0)\right\rangle</script><p>​    我们取时间步长为1，对任一时刻，我们计算$C_{n}$并与含时指数项和本征态相乘，就能得到这一时刻的全位置波函数，即代码中每一个循环的的 Psit。然后对每一时刻的波函数导出图片到当前目录下的 temp 文件夹，最后把这些图导出一个gif文件，即得到比较直观的含时演化过程。</p>
<p>​    此外，我们也可以把每一个时刻的 Psit 矢量记录下来，得到一个二维复数列表 Z[i][t], 其表示的是 i 点 t 时刻 的波函数的模方，这样以 i 和 t 为坐标轴绘制 surface 图，可以得到类似 ppt 上的高斯波包的时空演化分布</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建temp文件夹放演化图片</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./temp1&#x27;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&#x27;./temp1&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#Z:波函数模方</span></span><br><span class="line">Z = np.zeros((N,N))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="comment">#Psit:t时刻j基矢下的波函数矢量</span></span><br><span class="line">    Psit = np.zeros(N, dtype = <span class="built_in">complex</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        Psit += np.dot(V[:,i],Psi0) * np.exp(- <span class="number">1.0j</span> * E[i] * t) * V[:,i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        Z[i][t] = np.power(<span class="built_in">abs</span>(Psit[i]),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#绘制t时刻的图片</span></span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    plt.xlim(<span class="number">0</span>,N)</span><br><span class="line">    plt.ylim(<span class="number">0</span>,<span class="number">0.1</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;j&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;\psi&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        x.append(i+<span class="number">1</span>)</span><br><span class="line">        y.append(np.power(<span class="built_in">abs</span>(Psit[i]),<span class="number">2</span>))</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.savefig(<span class="string">&quot;./temp1/&quot;</span>+<span class="built_in">str</span>(t)+<span class="string">&quot;.png&quot;</span>)</span><br><span class="line">    plt.clf() </span><br><span class="line"></span><br><span class="line"><span class="comment">#读取这些图片，导出一张gif</span></span><br><span class="line"><span class="keyword">with</span> imageio.get_writer(<span class="string">&#x27;rt_evolution_1.gif&#x27;</span>, mode=<span class="string">&#x27;I&#x27;</span>) <span class="keyword">as</span> writer:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        filename = <span class="string">&#x27;./temp1/&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">        image = imageio.imread(filename)</span><br><span class="line">        writer.append_data(image)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制3D的surface图</span></span><br><span class="line">xx = np.arange(<span class="number">0</span>,N,<span class="number">1</span>)</span><br><span class="line">yy = np.arange(<span class="number">0</span>,N,<span class="number">1</span>)</span><br><span class="line">X , Y = np.meshgrid(xx,yy)</span><br><span class="line"><span class="comment">#绘制曲面图</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"><span class="comment">#调用plot_surface()函数</span></span><br><span class="line">ax.plot_surface(X,Y,Z,cmap = <span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;j&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;t&quot;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&quot;|\psi|^2&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;the time evolution of GWP&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;3dsurface_1.png&quot;</span>)</span><br><span class="line">plt.show() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>&lt;Figure size 432x288 with 0 Axes&gt;
</code></pre><p><img src="https://s2.loli.net/2022/10/08/k2lQazMcsR6KCwu.png" alt="3dsurface_1.png"><br><img src="https://s2.loli.net/2022/10/08/NjJFEUs5iazRXVM.gif" alt="rt_evolution_1.gif">    </p>
<ul>
<li><ol>
<li><p>分析和其他参数的尝试</p>
<p>如上所示，我们得到了一个含时演化的 gif 和一个时空撒点的 surface 图。前者放在了当前目录，即 rt_evolution_1.gif 文件</p>
<p>可以看到，对于初始条件 k = PI / 2， 开放边界 GWP 的含时演化是一个波包在震荡，其振幅点的轨迹类似一个椭圆。</p>
<p>和 ppt 中给出的不同的是， ppt中的波包会运动到边界碰撞回来，而我们计算的 GWP 不会运动到边界，而是大概在 20~80 之间震荡，这是因为这里的 GWP 比 ppt 中多了对角项，即 F * j</p>
<p>那么我们会想尝试一下其他参数的 GWP 是什么样子：</p>
<ul>
<li><p>EX1. 例如我们改变初始 k = 0，将结果存为 rt_evolution_2.gif 和 3dsurface_2.png</p>
</li>
<li><p>EX2. 再例如我们改变哈密顿对角项参数 F = 1，将结果存为 rt_evolution_3.gif 和 3dsurface_3.png</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>EX1. 改变 k = 0, rt_evolution_2.gif 中我们看到 GWP 在左半边演化，说明初始相位对波含时演化的影响</p>
<p><img src="https://s2.loli.net/2022/10/08/81FHBG3paLZ6Mbr.png" alt="3dsurface_2.png"></p>
<p><img src="https://s2.loli.net/2022/10/08/WEIptNXe4Ylh95D.gif" alt="rt_evolution_2.gif"></p>
</li>
<li><p>EX2. 改变 F = 1，即放大占据态的权重，rt_evolution_3.gif 中发现 GWP 震荡的空间范围缩小，这和前面分析一致，即 F 趋于零时退化到和 ppt 中只有 hopping 项一样的”碰壁”行为</p>
<p><img src="https://s2.loli.net/2022/10/08/4Q82alMnxOHNJrK.png" alt="3dsurface_3.png"></p>
<p><img src="https://s2.loli.net/2022/10/08/aW8dBfYN26gLZ7e.gif" alt="rt_evolution_3.gif"></p>
</li>
<li><p>除了以上参数改变外，也可以修改开放边界/环形边界（对应哈密顿量边界处取值），来可视化 GWP 行为，这里不再展开了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog Setup</title>
    <url>/2022/09/07/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="hexo-Github-博客搭建教程"><a href="#hexo-Github-博客搭建教程" class="headerlink" title="hexo+Github 博客搭建教程"></a>hexo+Github 博客搭建教程</h2><h3 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h3><p>感谢 Huanhao 老师的Blog教程。一直想做个个人博客，今天跟着教程由hexo搭建了一个简单的个人博客，记录一下。</p>
<h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;http://nodejs.cn/download/&gt;</span><br></pre></td></tr></table></figure>
<p>​    选择.msi安装包，一直点Next即可</p>
<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://git-scm.com/&gt;</span><br></pre></td></tr></table></figure>
<p>​    同上，一直点Next</p>
<h4 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h4><p>​    右键点击 Git Bash Here，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>​    检查安装成功与否：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>
<p>​    输出版本号说明安装成功</p>
<h3 id="3-Hexo"><a href="#3-Hexo" class="headerlink" title="3. Hexo"></a>3. Hexo</h3><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>​    在git bash中执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h4 id="建立博客"><a href="#建立博客" class="headerlink" title="建立博客"></a>建立博客</h4><p>​    在一个磁盘中建立一个文件夹，用于存放博客。例如我在E盘新建一个_blog文件夹，在该文件夹目录下，右键 Git Bash Here。然后执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/09/08/flPZTMN6r9SeJpb.png" alt="20220907156146484961.png"></p>
<pre><code> 执行命令：
</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/09/07/qlMOa7I9B6Xe2Go.png" alt="image-20220907222458798.png"></p>
<p>​    打开这个网站，可以看到预设好的网页</p>
<h3 id="4-更换主题及修改配置文件"><a href="#4-更换主题及修改配置文件" class="headerlink" title="4.更换主题及修改配置文件"></a>4.更换主题及修改配置文件</h3><h4 id="关于主题"><a href="#关于主题" class="headerlink" title="关于主题"></a>关于主题</h4><p>​    hexo主题可在如下网址中找到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://hexo.io/themes/&gt;</span><br></pre></td></tr></table></figure>
<p>​    新手入门的Next主题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预览效果：&lt;https://theme-next.org/&gt;</span><br><span class="line"></span><br><span class="line">项目地址：&lt;https://github.com/theme-next/hexo-theme-next&gt;</span><br><span class="line"></span><br><span class="line">配置文档：&lt;https://theme-next.org/docs/getting-started/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="关于下载主题"><a href="#关于下载主题" class="headerlink" title="关于下载主题"></a>关于下载主题</h4><p>​    打开主题的项目地址后，点击<code>Clone or download</code> ，然后在博客文件夹下面打开git bash，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 复制的地址 themes/主题名字</span><br></pre></td></tr></table></figure>
<h4 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h4><p>​    在 <code>_blog/</code> 下打开 <code>_config.yml</code>文件，找到<code>themes</code>这一行，然后将主题名字修改为next：</p>
<p><img src="https://s2.loli.net/2022/09/07/i8zVDl4p5QZkOnE.png" alt="image-20220907224141677.png"></p>
<p>​    在博客目录git bash，执行 hexo s ，打开浏览地址可以预览效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tip:有些主题你更换之后是暂时无法预览的，因为有的主题还需要安装它需要的依赖，这一般都会在主题的文档里面提到，只有安装它的依赖之后才可以正常预览</span><br></pre></td></tr></table></figure>
<h4 id="关于其他设置"><a href="#关于其他设置" class="headerlink" title="关于其他设置"></a>关于其他设置</h4><p>​    在Next主题的文档里面提到了如何更换语言以及更改主题的外观，如下：</p>
<p><img src="https://s2.loli.net/2022/09/07/sUm1V3ycpNShY2i.png" alt="image-20220907224613052.png"></p>
<p><img src="https://s2.loli.net/2022/09/07/pT6CdcQyLFjkeUb.png" alt="image-20220907224732227.png"></p>
<p>​    注意前者在 <strong>站点配置文件</strong>_config,yml 下，后者在 <strong>主题配置文件</strong>_config.yml 下</p>
<p>​    附非最新版本的主题文档中文版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;http://theme-next.iissnan.com/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-写博客"><a href="#5-写博客" class="headerlink" title="5. 写博客"></a>5. 写博客</h3><p>​    在博客根目录下git bash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;test blog&quot;</span><br></pre></td></tr></table></figure>
<p>​    在 source/_posts 下会建立markdown文件，编写后保存，在博客根目录下git bash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>​    可以预览写好的博客</p>
<h3 id="6-部署博客"><a href="#6-部署博客" class="headerlink" title="6. 部署博客"></a>6. 部署博客</h3><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>​    注册 github 账号</p>
<p>​    创建一个仓库</p>
<p>​    仓库名为用户名 + .github.io （必须）</p>
<h4 id="git密钥"><a href="#git密钥" class="headerlink" title="git密钥"></a>git密钥</h4><p>​    git bash</p>
<p>​    执行（里面是个人邮箱）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “your_email@your_email.com“</span><br></pre></td></tr></table></figure>
<p>​    一直回车，然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>​    会得到一串密钥，复制好信息，在 Github 个人主页 SSH and GPG keys 中 Add new，粘贴密钥</p>
<p>​    然后打开git bash，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$  ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>​    在这里复制地址</p>
<p><img src="https://s2.loli.net/2022/09/07/hlIqEWuKp48M1D7.png" alt="FCjahXQIlNoKUxO.png"></p>
<p>​    打开站点配置文件，修改deploy信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 复制的地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>​    在博客根目录下打开git bash，分别执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;yourname&quot;</span><br><span class="line">$ git config --global user.email &quot;youremail&quot;</span><br><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>​    完成以上配置后，即可上传，在博客根目录下git bash，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>​    结束后，在项目中点击 Settings</p>
<p>​    Pages 中，选择master branch</p>
<p><img src="https://s2.loli.net/2022/09/07/vThyb7e8aAPZctF.png" alt="image-20220907230345545.png"></p>
<p>​    完成简易的博客建立</p>
<h3 id="7-图床"><a href="#7-图床" class="headerlink" title="7. 图床"></a>7. 图床</h3><p>​        关于图片导入，需要上传到图床再链接。如下网址可用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://sm.ms/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog Setting</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/07/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Mathjax</title>
    <url>/2022/10/08/mathjax/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hexo-Next-Theme-如何显示数学公式"><a href="#Hexo-Next-Theme-如何显示数学公式" class="headerlink" title="Hexo Next Theme 如何显示数学公式"></a>Hexo Next Theme 如何显示数学公式</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>​    在用markdown写文档时，若包含数学公式，渲染会出现一些问题。常用的Markdown编辑器都会集成Mathjax，用来渲染文档中的类<a href="https://so.csdn.net/so/search?q=Latex&amp;spm=1001.2101.3001.7020">Latex</a>格式书写的数学公式，基于Hexo搭建的个人博客，需要对渲染文档进行一些修改。</p>
<h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h3><p>​    Hexo 默认使用 hexo-renderer-marked 引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签，比如在 markdown 语法中，下划线_代表斜体，会被渲染引擎处理为 $em$ 标签。</p>
<p>​    因为类 Latex 格式书写的数学公式下划线_表示下标，有特殊的含义，如果被强制转换为 $em$ 标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括*, {, }, \\等。</p>
<h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><h4 id="1-安装渲染器"><a href="#1-安装渲染器" class="headerlink" title="1. 安装渲染器"></a>1. 安装渲染器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h4><p>​    博客根目录下，找到 node_modules\kramed\lib\rules\inline.js，做如下修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure>
<p>​    重新启动 hexo （clean 再 generate）</p>
<p>​    另外，在主题配置文件中 _config.yml，把 mathjax 的 enable 修改为 true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">	enable: true</span><br></pre></td></tr></table></figure>
<h4 id="3-文章渲染标签"><a href="#3-文章渲染标签" class="headerlink" title="3.  文章渲染标签"></a>3.  文章渲染标签</h4><p>​    在文章的Front-matter里打开mathjax开关，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: xxxx</span><br><span class="line">date: xxxx-xx-xx xx:xx:xx</span><br><span class="line">categories: xx</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>
<p>​    OK</p>
]]></content>
      <categories>
        <category>Blog Setting</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Semiconductor Physics(section 0)</title>
    <url>/2022/10/26/Semiconductor%20physics0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><u><em>The original source is from YouTube up Jodan Edmunds</em></u></p>
<p>Firstly, we raise two central questions in semiconductor physics.</p>
<ol>
<li>How many charge carries do we have?</li>
<li>Where are they and how are they moving?</li>
</ol>
<p>Here is a little road map:</p>
<pre class="mermaid">graph TD;
    C([Conservation <br> laws])
    A["Quantum Mech <br> and Stat Mech"] --> DOS & E/k & B[ferimi Stat]
    DOS & E/k & B[ferimi Stat] --> D["How many? <br> &int; DOS FS dE"]</pre>



<pre class="mermaid">graph TD;
    A["Maxwell's Eq and <br> Prob Theory"] --> B[Carrier Drift] & C[Carrier Diffusion] & D["Generation && <br> Recombination"]
    B --> E[Ohm's Law]
    B & C & D --> F["Continuity Eq and <br> Ambipolar transport"]
    F --> G[P/N junctions] & P[diodes] & H[MOSFETs,BJTs] & Q[Optical Devices]</pre>



]]></content>
      <categories>
        <category>Semiconductor Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF upload and preview</title>
    <url>/2022/10/25/PDF-upload-and-preview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hexo博客上传本地文件以及实现PDF预览"><a href="#Hexo博客上传本地文件以及实现PDF预览" class="headerlink" title="Hexo博客上传本地文件以及实现PDF预览"></a>Hexo博客上传本地文件以及实现PDF预览</h2><h3 id="上传本地文件"><a href="#上传本地文件" class="headerlink" title="上传本地文件"></a>上传本地文件</h3><p>把文件放在<code>source</code>文件下，再使用<code>hexo d</code>部署时，文件会自动被上传到Github上。为了便于文件管理和组织，可以在<code>source</code>文件下新建<code>file</code>文件夹用于分类存储文件。</p>
<p>使用<code>hexo d</code>部署后，文件的链接是<code>博客域名/file/文件名</code>。</p>
<p>有两点需要注意：</p>
<ol>
<li>链接中需要包含文件名的后缀；</li>
<li>文件名最好由数字和字母组成，不要包含中文、空格或这特殊字符。解析时候容易出错。</li>
</ol>
<h3 id="添加hexo博客book导航栏"><a href="#添加hexo博客book导航栏" class="headerlink" title="添加hexo博客book导航栏"></a>添加hexo博客book导航栏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page book</span><br></pre></td></tr></table></figure>
<p>在主题配置文件夹下添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book:</span><br><span class="line">	url: /book</span><br><span class="line">	icon: fas fa-book</span><br></pre></td></tr></table></figure>
<p>在book文件夹中的index.md中添加你生成的pdf文件链接即可</p>
<h3 id="文章中添加pdf预览功能"><a href="#文章中添加pdf预览功能" class="headerlink" title="文章中添加pdf预览功能"></a>文章中添加pdf预览功能</h3><p>PDF预览功能需要借助<a href="https://github.com/superalsrk/hexo-pdf/">hexo-pdf插件</a>实现。插件非常小巧方便，关于插件的安装和使用，插件作者已经在主页介绍的很详细了。</p>
<ol>
<li>hexo-pdf插件。通过npm安装，注意是在hexo根目录下执行该语句。<code>npm install --save hexo-pdf</code></li>
<li>应用。在文章合适位置插入代码。对于一般的PDF文件、Google Driver和Slideshare都可以使用<code>&#123;% pdf 链接 %&#125;</code>的形式，例如<code>&#123;% pdf http://xsdg217.github.io/221020fang.pdf %&#125;</code>。对于一般的PDF文件也可以本地PDF。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/qq_43827595/article/details/104574959">【如何在网页中实现pdf在线预览】10分钟学会如何利用Hexo博客上传本地pdf文件并在线预览pdf</a></p>
]]></content>
      <categories>
        <category>Blog Setting</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Tranditional DMRG on transverse-field Ising model</title>
    <url>/2022/10/30/HW_DMRG/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size = 5> Homework </font>

<ul>
<li><p>consider the transverse-field Ising model on a N-site chain</p>
<p>  please take the following parameters for homework:</p>
<p>  N = 30, J = 1, g $\in$ [0.7, 1.0, 1.7]</p>
<p>  keeping a maximum of m states in the new basis, m $\in$ [10, 20, 30]</p>
</li>
</ul>
<script type="math/tex; mode=display">
\begin{gathered}
H=-J \sum_{i=1}^{N-1}\left(g \sigma_i^x+\sigma_i^z \sigma_{i+1}^z\right) \quad J, g \geq 0 \\
\sigma^x=\left(\begin{array}{ll}
0 & 1 \\
1 & 0
\end{array}\right), \sigma^z=\left(\begin{array}{cc}
1 & 0 \\
0 & -1
\end{array}\right)
\end{gathered}</script><ul>
<li><p>based on the traditional finite size DMRG method, e.g.,</p>
<p>  <a href="https://github.com/simple-dmrg/simple-dmrg">https://github.com/simple-dmrg/simple-dmrg</a> (finite system algorithm)</p>
<p>  plot the entanglement entropy S(L) as a function of L, $S(L)=-\operatorname{Tr}\left[\rho_L \ln \rho_L\right]$</p>
<p>  explicitly show the data of ground state energy and entanglement entropy</p>
<p>  \begin{equation}<br>  \text { (1) } m=30, g \in[0.7,1.0,1.7] \text {, (2) } g=1.0, m \in[10,20,30]<br>  \end{equation}</p>
</li>
</ul>
<ul>
<li><p>简要思路分析：</p>
<p>  对 github 上的 finite system algorithm 部分进行改写。其中主要思路如下：</p>
<ol>
<li><p>根据哈密顿量形式定义单体和两体的 H，定义 block 数据类型作为传递；</p>
</li>
<li><p>enlarge_block 函数实现向当前的 block 添加一个节点的“扩展”，主要考虑三部分变化：current block 内的两体哈密顿量， 新节点内的单体哈密顿量，以及二者连接处的两体哈密顿量；</p>
</li>
<li><p>单步DMRG，执行一个DMRG步骤，使用’ sys ‘作为系统，’ env ‘作为环境，截取 m 个基矢；</p>
</li>
<li><p>Traditional finite DMRG algorithm， 先做 infinte 的 DMRG 的 enlarge， 将结果存到 block_disk 中方便后面调用。然后做 full size 的 finite DMRG，即 sweep back and forth 直到收敛</p>
</li>
</ol>
</li>
<li><p>对源代码的修改主要包括几个部分：</p>
<ol>
<li><p>哈密顿量单体和两体作用，以及后面调用接口的修改；</p>
</li>
<li><p>密度矩阵 rho 作为结果 return， 并计算纠缠熵。我们知道矩阵的迹等于其特征值的和，据此来计算 S(L)；</p>
</li>
<li><p>收敛判据。原代码对于每一个 m ，做了一个周期的 sweep，这里将收敛判据改成 E/L 的收敛情况（尽管经过测试，原代码也收敛）；</p>
</li>
<li><p>其他（例如L,m_warmup参数修改等 trivial 的地方）。</p>
</li>
</ol>
</li>
<li><p>一点说明：EE[] 存储纠缠熵相关数据，EL[] 存储基态能量相关数据</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simple DMRG tutorial.  This code integrates the following concepts:</span></span><br><span class="line"><span class="comment">#  - Infinite system algorithm</span></span><br><span class="line"><span class="comment">#  - Finite system algorithm</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright 2013 James R. Garrison and Ryan V. Mishmash.</span></span><br><span class="line"><span class="comment"># Open source under the MIT license.  Source code at</span></span><br><span class="line"><span class="comment"># &lt;https://github.com/simple-dmrg/simple-dmrg/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This code will run under any version of Python &gt;= 2.6.  The following line</span></span><br><span class="line"><span class="comment"># provides consistency between python2 and python3.</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function, division  <span class="comment"># requires Python &gt;= 2.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy and scipy imports</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> kron, identity</span><br><span class="line"><span class="keyword">from</span> scipy.sparse.linalg <span class="keyword">import</span> eigsh  <span class="comment"># Lanczos routine from ARPACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We will use python&#x27;s &quot;namedtuple&quot; to represent the Block and EnlargedBlock</span></span><br><span class="line"><span class="comment"># objects</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Block = namedtuple(<span class="string">&quot;Block&quot;</span>, [<span class="string">&quot;length&quot;</span>, <span class="string">&quot;basis_size&quot;</span>, <span class="string">&quot;operator_dict&quot;</span>])</span><br><span class="line">EnlargedBlock = namedtuple(<span class="string">&quot;EnlargedBlock&quot;</span>, [<span class="string">&quot;length&quot;</span>, <span class="string">&quot;basis_size&quot;</span>, <span class="string">&quot;operator_dict&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid_block</span>(<span class="params">block</span>):</span><br><span class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> block.operator_dict.values():</span><br><span class="line">        <span class="keyword">if</span> op.shape[<span class="number">0</span>] != block.basis_size <span class="keyword">or</span> op.shape[<span class="number">1</span>] != block.basis_size:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This function should test the same exact things, so there is no need to</span></span><br><span class="line"><span class="comment"># repeat its definition.</span></span><br><span class="line">is_valid_enlarged_block = is_valid_block</span><br><span class="line"></span><br><span class="line"><span class="comment"># Model-specific code for the TF Ising Model</span></span><br><span class="line">model_d = <span class="number">2</span>  <span class="comment"># single-site basis size</span></span><br><span class="line"></span><br><span class="line">Sz1 = np.array([[<span class="number">1.0</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1.0</span>]], dtype=<span class="string">&#x27;d&#x27;</span>)  <span class="comment"># single-site S^z</span></span><br><span class="line">Sx1 = np.array([[<span class="number">0</span>, <span class="number">1.0</span>], [<span class="number">1.0</span>, <span class="number">0</span>]], dtype=<span class="string">&#x27;d&#x27;</span>)  <span class="comment"># single-site S^x</span></span><br><span class="line">EE = []</span><br><span class="line">EL = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vn_eig_entropy</span>(<span class="params">rho</span>):</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    <span class="keyword">from</span> scipy <span class="keyword">import</span> linalg <span class="keyword">as</span> la</span><br><span class="line">    <span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line">    EV = la.eigvals(rho)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Drop zero eigenvalues so that log2 is defined</span></span><br><span class="line">    my_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> EV.tolist() <span class="keyword">if</span> x]</span><br><span class="line">    EV = np.array(my_list)</span><br><span class="line"></span><br><span class="line">    ln_EV = np.matrix(np.log(EV))</span><br><span class="line">    EV = np.matrix(EV)</span><br><span class="line">    S = -np.dot(EV, ln_EV.H)</span><br><span class="line">    <span class="keyword">return</span>(S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">H1</span>(<span class="params">Sx1, g</span>):    <span class="comment"># single-site part of H</span></span><br><span class="line">    J = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> - J * g * Sx1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">H2</span>(<span class="params">Sz1, Sz2</span>):  <span class="comment"># two-site part of H</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Given the operators S^z and S^+ on two sites in different Hilbert spaces</span></span><br><span class="line"><span class="string">    (e.g. two blocks), returns a Kronecker product representing the</span></span><br><span class="line"><span class="string">    corresponding two-site term in the Hamiltonian that joins the two sites.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    J = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        - J * kron(Sz1, Sz2)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enlarge_block</span>(<span class="params">block, g</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This function enlarges the provided Block by a single site, returning an</span></span><br><span class="line"><span class="string">    EnlargedBlock.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mblock = block.basis_size</span><br><span class="line">    o = block.operator_dict</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the new operators for the enlarged block.  Our basis becomes a</span></span><br><span class="line">    <span class="comment"># Kronecker product of the Block basis and the single-site basis.  <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment"># `kron` uses the tensor product convention making blocks of the second</span></span><br><span class="line">    <span class="comment"># array scaled by the first.  As such, we adopt this convention for</span></span><br><span class="line">    <span class="comment"># Kronecker products throughout the code.</span></span><br><span class="line">    enlarged_operator_dict = &#123;</span><br><span class="line">        <span class="string">&quot;H&quot;</span>: kron(o[<span class="string">&quot;H&quot;</span>], identity(model_d)) + kron(identity(mblock), H1(Sx1, g)) + H2(o[<span class="string">&quot;conn_Sz&quot;</span>], Sz1),</span><br><span class="line">        <span class="string">&quot;conn_Sz&quot;</span>: kron(identity(mblock), Sz1),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EnlargedBlock(length=(block.length + <span class="number">1</span>),</span><br><span class="line">                         basis_size=(block.basis_size * model_d),</span><br><span class="line">                         operator_dict=enlarged_operator_dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotate_and_truncate</span>(<span class="params">operator, transformation_matrix</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Transforms the operator to the new (possibly truncated) basis given by</span></span><br><span class="line"><span class="string">    `transformation_matrix`.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> transformation_matrix.conjugate().transpose().dot(operator.dot(transformation_matrix))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_dmrg_step</span>(<span class="params">sys, env, m, g</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Performs a single DMRG step using `sys` as the system and `env` as the</span></span><br><span class="line"><span class="string">    environment, keeping a maximum of `m` states in the new basis.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> is_valid_block(sys)</span><br><span class="line">    <span class="keyword">assert</span> is_valid_block(env)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Enlarge each block by a single site.</span></span><br><span class="line">    sys_enl = enlarge_block(sys, g)</span><br><span class="line">    <span class="keyword">if</span> sys <span class="keyword">is</span> env:  <span class="comment"># no need to recalculate a second time</span></span><br><span class="line">        env_enl = sys_enl</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env_enl = enlarge_block(env, g)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_valid_enlarged_block(sys_enl)</span><br><span class="line">    <span class="keyword">assert</span> is_valid_enlarged_block(env_enl)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the full superblock Hamiltonian.</span></span><br><span class="line">    m_sys_enl = sys_enl.basis_size</span><br><span class="line">    m_env_enl = env_enl.basis_size</span><br><span class="line">    sys_enl_op = sys_enl.operator_dict</span><br><span class="line">    env_enl_op = env_enl.operator_dict</span><br><span class="line">    superblock_hamiltonian = kron(sys_enl_op[<span class="string">&quot;H&quot;</span>], identity(m_env_enl)) + kron(identity(m_sys_enl), env_enl_op[<span class="string">&quot;H&quot;</span>]) + \</span><br><span class="line">                             H2(sys_enl_op[<span class="string">&quot;conn_Sz&quot;</span>], env_enl_op[<span class="string">&quot;conn_Sz&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Call ARPACK to find the superblock ground state.  (&quot;SA&quot; means find the</span></span><br><span class="line">    <span class="comment"># &quot;smallest in amplitude&quot; eigenvalue.)</span></span><br><span class="line">    (energy,), psi0 = eigsh(superblock_hamiltonian, k=<span class="number">1</span>, which=<span class="string">&quot;SA&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the reduced density matrix of the system by tracing out the</span></span><br><span class="line">    <span class="comment"># environment</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># We want to make the (sys, env) indices correspond to (row, column) of a</span></span><br><span class="line">    <span class="comment"># matrix, respectively.  Since the environment (column) index updates most</span></span><br><span class="line">    <span class="comment"># quickly in our Kronecker product structure, psi0 is thus row-major (&quot;C</span></span><br><span class="line">    <span class="comment"># style&quot;).</span></span><br><span class="line">    psi0 = psi0.reshape([sys_enl.basis_size, -<span class="number">1</span>], order=<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    rho = np.dot(psi0, psi0.conjugate().transpose())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Diagonalize the reduced density matrix and sort the eigenvectors by</span></span><br><span class="line">    <span class="comment"># eigenvalue.</span></span><br><span class="line">    evals, evecs = np.linalg.eigh(rho)</span><br><span class="line">    possible_eigenstates = []</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">eval</span>, evec <span class="keyword">in</span> <span class="built_in">zip</span>(evals, evecs.transpose()):</span><br><span class="line">        possible_eigenstates.append((<span class="built_in">eval</span>, evec))</span><br><span class="line">    possible_eigenstates.sort(reverse=<span class="literal">True</span>, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])  <span class="comment"># largest eigenvalue first</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the transformation matrix from the `m` overall most significant</span></span><br><span class="line">    <span class="comment"># eigenvectors.</span></span><br><span class="line">    my_m = <span class="built_in">min</span>(<span class="built_in">len</span>(possible_eigenstates), m)</span><br><span class="line">    transformation_matrix = np.zeros((sys_enl.basis_size, my_m), dtype=<span class="string">&#x27;d&#x27;</span>, order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, (<span class="built_in">eval</span>, evec) <span class="keyword">in</span> <span class="built_in">enumerate</span>(possible_eigenstates[:my_m]):</span><br><span class="line">        transformation_matrix[:, i] = evec</span><br><span class="line"></span><br><span class="line">    truncation_error = <span class="number">1</span> - <span class="built_in">sum</span>([x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> possible_eigenstates[:my_m]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;truncation error:&quot;</span>, truncation_error)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Rotate and truncate each operator.</span></span><br><span class="line">    new_operator_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> name, op <span class="keyword">in</span> sys_enl.operator_dict.items():</span><br><span class="line">        new_operator_dict[name] = rotate_and_truncate(op, transformation_matrix)</span><br><span class="line"></span><br><span class="line">    newblock = Block(length=sys_enl.length,</span><br><span class="line">                     basis_size=my_m,</span><br><span class="line">                     operator_dict=new_operator_dict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newblock, energy, rho</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">graphic</span>(<span class="params">sys_block, env_block, sys_label=<span class="string">&quot;l&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a graphical representation of the DMRG step we are about to</span></span><br><span class="line"><span class="string">    perform, using &#x27;=&#x27; to represent the system sites, &#x27;-&#x27; to represent the</span></span><br><span class="line"><span class="string">    environment sites, and &#x27;**&#x27; to represent the two intermediate sites.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> sys_label <span class="keyword">in</span> (<span class="string">&quot;l&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    graphic = (<span class="string">&quot;=&quot;</span> * sys_block.length) + <span class="string">&quot;**&quot;</span> + (<span class="string">&quot;-&quot;</span> * env_block.length)</span><br><span class="line">    <span class="keyword">if</span> sys_label == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">        <span class="comment"># The system should be on the right and the environment should be on</span></span><br><span class="line">        <span class="comment"># the left, so reverse the graphic.</span></span><br><span class="line">        graphic = graphic[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> graphic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">finite_system_algorithm</span>(<span class="params">L, m_warmup, m_sweep_list, g</span>):</span><br><span class="line">    <span class="keyword">assert</span> L % <span class="number">2</span> == <span class="number">0</span>  <span class="comment"># require that L is an even number</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To keep things simple, this dictionary is not actually saved to disk, but</span></span><br><span class="line">    <span class="comment"># we use it to represent persistent storage.</span></span><br><span class="line">    block_disk = &#123;&#125;  <span class="comment"># &quot;disk&quot; storage for Block objects</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use the infinite system algorithm to build up to desired size.  Each time</span></span><br><span class="line">    <span class="comment"># we construct a block, we save it for future reference as both a left</span></span><br><span class="line">    <span class="comment"># (&quot;l&quot;) and right (&quot;r&quot;) block, as the infinite system algorithm assumes the</span></span><br><span class="line">    <span class="comment"># environment is a mirror image of the system.</span></span><br><span class="line">    <span class="comment"># conn refers to the connection operator, that is, the operator on the edge of</span></span><br><span class="line">    <span class="comment"># the block, on the interior of the chain.  We need to be able to represent S^z</span></span><br><span class="line">    <span class="comment"># on that site in the current basis in order to grow the chain.</span></span><br><span class="line">    initial_block = Block(length=<span class="number">1</span>, basis_size=model_d, operator_dict=&#123;</span><br><span class="line">        <span class="string">&quot;H&quot;</span>: H1(Sx1, g),</span><br><span class="line">        <span class="string">&quot;conn_Sz&quot;</span>: Sz1,</span><br><span class="line">    &#125;)</span><br><span class="line">    block = initial_block</span><br><span class="line">    block_disk[<span class="string">&quot;l&quot;</span>, block.length] = block</span><br><span class="line">    block_disk[<span class="string">&quot;r&quot;</span>, block.length] = block</span><br><span class="line">    <span class="keyword">while</span> <span class="number">2</span> * block.length &lt; L:</span><br><span class="line">        <span class="comment"># Perform a single DMRG step and save the new Block to &quot;disk&quot;</span></span><br><span class="line">        <span class="comment">#print(graphic(block, block))</span></span><br><span class="line">        block, energy, rho = single_dmrg_step(block, block, m=m_warmup, g =g )</span><br><span class="line">        <span class="comment">#print(&quot;E/L =&quot;, energy / (block.length * 2))</span></span><br><span class="line">        block_disk[<span class="string">&quot;l&quot;</span>, block.length] = block</span><br><span class="line">        block_disk[<span class="string">&quot;r&quot;</span>, block.length] = block</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now that the system is built up to its full size, we perform sweeps using</span></span><br><span class="line">    <span class="comment"># the finite system algorithm.  At first the left block will act as the</span></span><br><span class="line">    <span class="comment"># system, growing at the expense of the right block (the environment), but</span></span><br><span class="line">    <span class="comment"># once we come to the end of the chain these roles will be reversed.</span></span><br><span class="line">    sys_label, env_label = <span class="string">&quot;l&quot;</span>, <span class="string">&quot;r&quot;</span></span><br><span class="line">    sys_block = block; <span class="keyword">del</span> block  <span class="comment"># rename the variable</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> m_sweep_list:</span><br><span class="line">        pre_energy = <span class="number">1.</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># Load the appropriate environment block from &quot;disk&quot;</span></span><br><span class="line">            env_block = block_disk[env_label, L - sys_block.length - <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Perform a single DMRG step.</span></span><br><span class="line">            <span class="built_in">print</span>(graphic(sys_block, env_block, sys_label))</span><br><span class="line">            <span class="comment">#记录一下之前的 E</span></span><br><span class="line">            </span><br><span class="line">            sys_block, energy, rho = single_dmrg_step(sys_block, env_block, m=m, g=g)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#print(&quot;E/L =&quot;, energy / L)</span></span><br><span class="line">            <span class="comment">#计算纠缠熵</span></span><br><span class="line">            S = np.real(vn_eig_entropy(rho)[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            s = <span class="built_in">float</span>(S[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="comment">#加入到 EE,EL 数组中</span></span><br><span class="line">            EE.append([s, sys_block.length, m, g])</span><br><span class="line">            EL.append([g, energy/L])</span><br><span class="line">            <span class="comment">#反转</span></span><br><span class="line">            <span class="keyword">if</span> env_block.length == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># We&#x27;ve come to the end of the chain, so we reverse course.</span></span><br><span class="line">                sys_block, env_block = env_block, sys_block</span><br><span class="line">                sys_label, env_label = env_label, sys_label</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Save the block from this step to disk.</span></span><br><span class="line">            block_disk[sys_label, sys_block.length] = sys_block</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Check whether we just completed a full sweep.</span></span><br><span class="line">            <span class="comment">#if sys_label == &quot;l&quot; and 2 * sys_block.length == L:</span></span><br><span class="line">            <span class="comment">#    break  # escape from the &quot;while True&quot; loop</span></span><br><span class="line">            <span class="keyword">if</span> sys_label == <span class="string">&quot;l&quot;</span> <span class="keyword">and</span> <span class="number">2</span> * sys_block.length == L:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            <span class="comment">#print(pre_energy - energy)</span></span><br><span class="line">            <span class="keyword">if</span> np.<span class="built_in">abs</span>(energy/L - pre_energy/L) &lt; <span class="number">1e-16</span> <span class="keyword">and</span> flag == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pre_energy = energy</span><br><span class="line">            <span class="comment">#循环条件是至少跑一个周期的sweep的基础上，前后energy差大于1e-16</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一问：m =30 ，g 取 [0.7,1.0,1.7]</p>
</li>
<li><p>数组 EE 储存的是 [s, sys_block.length, m, g ], 分别对应：纠缠熵， 系统block长度，截断m，参数g。</p>
</li>
<li><p>下面输出的是 g 不同取值下的 data of ground state energy 以及 entanglement entropy（图从左往右是g取0.7，1.0，1.7）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(precision=<span class="number">10</span>, suppress=<span class="literal">True</span>, threshold=<span class="number">10000</span>, linewidth=<span class="number">300</span>)</span><br><span class="line">plt.figure(figsize = (<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">0.7</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;g=0.7&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">1.0</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;g=1.0&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">1.7</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;g=1.7&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p><img src="https://s2.loli.net/2022/10/30/kH8NevQ16ugmiAa.png" alt="HW_DMRG_7_1.png"></p>
<ul>
<li><p>可见在边界处（L较小或较大处）纠缠熵比较小，在中间纠缠熵比较大。这是符合我们的物理直觉的：边界上系统/环境 block 组成小，纠缠的混乱程度（熵）相对小。</p>
</li>
<li><p>此外可见 g 的不同取值会影响纠缠熵，对于 g 远离 1 的取值，可见他们中间比较平滑，对于 g  = 1 ， 有点像一个抛物线， 可能与 g = 1 是 TF Ising Model 的相变点有关。</p>
</li>
<li><p>为了更加直观地说明收敛情况，这里画出了 E/L 随着 DMRG 次数增长的变化，如下图所示，从左往右分别是 g = 0.7，1.0，1.7，横坐标是 DMRG 步数， 纵坐标是 E/L 大小。用的收敛条件是：至少 sweep 一个周期的基础上，直到 E/L 差值小于 1e-16。由下图可知，其实原代码的写法就已经收敛了。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EL1,EL2,EL3 =[], [], []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> EL:</span><br><span class="line">    <span class="keyword">if</span> item[<span class="number">0</span>] == <span class="number">0.7</span>:</span><br><span class="line">        EL1.append(item[<span class="number">1</span>])  </span><br><span class="line">    <span class="keyword">elif</span> item[<span class="number">0</span>] == <span class="number">1.0</span>:</span><br><span class="line">        EL2.append(item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> item[<span class="number">0</span>] == <span class="number">1.7</span>:</span><br><span class="line">        EL3.append(item[<span class="number">1</span>]) </span><br><span class="line">plt.figure(figsize = (<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot([x <span class="keyword">for</span> x <span class="keyword">in</span> EL1])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot([x <span class="keyword">for</span> x <span class="keyword">in</span> EL2])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot([x <span class="keyword">for</span> x <span class="keyword">in</span> EL3])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/10/30/vc41Kxh9EQowka3.png" alt="HW_DMRG_9_1.png"></p>
<ul>
<li><p>第二题， g = 1.0 , m =[10,20,30]</p>
</li>
<li><p>取不同大小的截断 basis，下面输出的是 m 不同取值下的 data of ground state energy 以及 entanglement entropy（图从左往右是m取10，20，30）：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(precision=<span class="number">10</span>, suppress=<span class="literal">True</span>, threshold=<span class="number">10000</span>, linewidth=<span class="number">300</span>)</span><br><span class="line">plt.figure(figsize = (<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">10</span>, m_sweep_list=[<span class="number">10</span>], g = <span class="number">1.0</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;m=10&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">20</span>, m_sweep_list=[<span class="number">20</span>], g = <span class="number">1.0</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;m=20&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">1.0</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;m=30&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/10/30/h247qrDxaJXo6AF.png" alt="HW_DMRG_11_1.png"></p>
<ul>
<li>由上图可见，对于 m 取 10，20，30 而言，纠缠熵 S(L) 并无明显差异；此外对不同的 m ， E/L 的值也都大致收敛到 -1.2612699.</li>
</ul>
<p><font size = 5>Extension</font></p>
<ul>
<li>前面两题讨论了几个不同的 m/g 值下的 S(L)，其中发现对 g = 0.7， g = 1.7 的 S(L) 有相似性，估计其“形状”在 g = 1 “对称”，下面再多算几组 g [0.85,0.95,1.05,1.15]，如下图所示，可见 $g \leq 1$ 时峰逐渐变尖， $g \geq 1$时峰逐渐变平坦，印证了前面的猜测。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(precision=<span class="number">10</span>, suppress=<span class="literal">True</span>, threshold=<span class="number">10000</span>, linewidth=<span class="number">300</span>)</span><br><span class="line">plt.figure(figsize = (<span class="number">20</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">0.85</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;g=0.85&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">0.95</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;g=0.95&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">1.05</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;g=1.05&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br><span class="line"></span><br><span class="line">finite_system_algorithm(L=<span class="number">30</span>, m_warmup=<span class="number">30</span>, m_sweep_list=[<span class="number">30</span>], g = <span class="number">1.15</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">plt.scatter([EE[x][<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))], [EE[y][<span class="number">0</span>] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(EE))])</span><br><span class="line">plt.title(<span class="string">&quot;g=1.15&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;S(L)&quot;</span>)</span><br><span class="line">EE.clear()</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/10/30/erwOLEVKpoqTjGb.png" alt="HW_DMRG_14_1.png"></p>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Semiconductor Physics(section 1)</title>
    <url>/2022/10/30/Semiconductor%20physics1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="A-Quantum-mechanics"><a href="#A-Quantum-mechanics" class="headerlink" title="A. Quantum mechanics"></a>A. Quantum mechanics</h3><p>Suppose you have learnt Quantum Mechanics, here is just a brief review.<br>Some assumptions:</p>
<ol>
<li>Energy quantization:<br> Different from traditional physics, we’re only allowed to exchange energy in individual packets, called photons, and the energy of this packet is just ‘h’ times the frequency ‘f’, i.e.:<script type="math/tex; mode=display">E = h\times f</script></li>
<li>Uncertainty principle:<br> The position of a moving particle and its momentum cannot be determined simultaneously, i.e.:<script type="math/tex; mode=display">\Delta x \Delta p \geq \frac{\hbar}{2}</script> another version with energy:<script type="math/tex; mode=display">\Delta E\Delta t \geq {\hbar}</script></li>
<li>Particles are waves:<script type="math/tex; mode=display">\lambda = \dfrac{h}{p}</script>Electrons must be described by $\Psi$, probability density $\propto |\Psi|^2$</li>
</ol>
<p>Based on these three assumptions, how do we “do” QM? Answer is Schroedinger Equation(S.Eq):</p>
<script type="math/tex; mode=display">H\phi = -\dfrac{\hbar}{2m}\nabla^2\phi+V\phi=E\phi</script><h3 id="B-Wave-number-‘k’"><a href="#B-Wave-number-‘k’" class="headerlink" title="B. Wave number ‘k’"></a>B. Wave number ‘k’</h3><p>The usual solution of S.Eq is :</p>
<script type="math/tex; mode=display">\phi = A\sin kx +B\cos kx</script><p>​    where $k = \sqrt{\dfrac{2mE}{\hbar^2}}$</p>
<p>​    So what’s the meaning of k? We know that k usually is the wave number in sine wave. </p>
<p>​    Like $T = 2 \pi /w$， k represents the spatial frequency or how fast something changes in space.</p>
<p>​    In QM, k is related to momentum:</p>
<script type="math/tex; mode=display">p = \hbar k</script><p>​    for $E =p^2/2m$, we have:</p>
<script type="math/tex; mode=display">k = p/ \hbar = \sqrt{\dfrac{2mE}{\hbar^2}}</script><p>​    S.Eq gives the relationship between wave number k and energy E. i.e. E(k)    </p>
]]></content>
      <categories>
        <category>Semiconductor Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Topology electronic</title>
    <url>/2022/10/31/fang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="pdfobject-container" data-target="./fang.pdf" data-height="500px"></div>]]></content>
      <categories>
        <category>Academic Report</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Product Operators (MPOs) in compass model</title>
    <url>/2022/11/06/HW_MPO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size = 5> Homework </font>

<ul>
<li><p>write down the MPO for the compass model on a square lattice</p>
<p>  $H=-J_x \sum_{\langle i, j\rangle_H} \sigma_i^x \sigma_j^x-J_y \sum_{\langle i, j\rangle_V} \sigma_i^y \sigma_j^y+h_z \sum_i \sigma_i^z$</p>
<p>  $\langle i, j\rangle_H \in(0,3),(3,6),(1,4),(4,7),(2,5),(5,8)$</p>
<p>  $\langle i, j\rangle_V \in(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(6,7),(7,8),(8,6)$</p>
<p>  $J_x=0.3, J_y=1.4, h_z=0.5, \sigma^x$ and $\sigma^y$ are Pauli matrices</p>
  <div  align="left">    
  <img src=https://s2.loli.net/2022/11/06/MaEcbXDkrLWsGYC.png style="zoom:90%" />  
  </div>
</li>
<li><p>(1) show the finite automata figure like this：</p>
<p>  <a href="https://sm.ms/image/6zLvtHqX4pJ2UNI" target="_blank"><img src="https://s2.loli.net/2022/11/06/6zLvtHqX4pJ2UNI.png" ></a></p>
</li>
<li><p>(2) write a code to generate these MPO, contract MPO tensors to obtain the Hamiltonian. </p>
<p>  show the lowest 20 eigenvalues, compare Hamiltonian and eigenvalues with exact diagonalization</p>
</li>
</ul>
<font size =4> A brief summary of theory and algorithm </font>

<ul>
<li><p>根据参考文献$ ^{[1]}$，对于一般的哈密顿量，其 Finite automata for MPO 构造规则如下：</p>
<ul>
<li><p>(1) 首先在第1行设置一个出发点0，一个与 Hamiltonian 同阶的单位阵Identity是必要的，先来处理site间的问题，先观察Hamiltonian中求和下标i的不同算符有多少，假设有N个，则分别从0发射N个不同的箭头线，然后将各自的算符ABC标记在箭头线上，如果这个求和项有非1的常系数，则只加在这一步所写的算符前，将箭头的终点按序编号;</p>
</li>
<li><p>(2) 从第2行的最左侧开始，观察跟在求和下标i之后的下标i+N的不同算符，同样方法地从每个点发射等同于不同算符数目的箭头线，箭头线根据N分为N段，仅在最后一段箭头线上标记下标i+N对应的算符，其它段标记 Identity ，则这一支对应i和i+N的求和项。对箭头线中间的端点进行编号，注意带有非 Identity 算符箭头线的终点不参与编号。编号按行从左到右从上到下依次增大;</p>
</li>
<li><p>(3) 重复步骤2直到所有 site 间的求和项都写完，把所有带有非 Identity 算符的未参与编号的箭头线末端都指向一个共同终点，如果中间一共写了 K-1 个点，那么终点按同样的规则编号为K。on-site 作用项直接写在出发点0直接指向终点K的连线上即可;</p>
<p><a href="https://sm.ms/image/z1mhMtesy4UDvqr" target="_blank"><img src="https://s2.loli.net/2022/11/06/z1mhMtesy4UDvqr.jpg" ></a></p>
</li>
<li><p>(4) 生成一个 (K+1)×(K+1)  的矩阵框架，行序号和列序号均为 0~K，然后按照 行→列（或者 列→行，这样得到的结果是前者的转置，是等价的）应用上图填满整个矩阵，就得到了MPO。比如0→1箭头线上是A，则在矩阵的0行1列填A。注意这里得到的矩阵是 $W^{[i]}$ ，它的第0行是 $W^{[1]}$ ，第K列是 $W^{[N]}$ （如果是列→行，则第K行是 $W^{[1]}$ ，第0列是 $W^{[N]}$ ）。</p>
</li>
</ul>
</li>
</ul>
<font size =4> An original attempt: problems encountered and solutions </font>

<ul>
<li><p>最初的想法：根据课件和上述参考文献，写出 MPO，然后类似下文中的 <em>MPO generate Hamiltonian OP</em> 生成哈密顿量来 check</p>
</li>
<li><p>遇到的问题：发现对于 onsite 项（Sz）和 H 方向项（Sx），哈密顿量是对的；但是 V 方向项（Sy）的哈密顿量不正确。具体如下（先忽略 onsite 的 trival 项）：</p>
  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/06/nowRJUjTvdcDgua.png style="zoom:90%" />   
  </div>
</li>
<li><p>可以注意到，Sx 相关项是正确的，Sy 相关项不正确：似乎多描述了一些 interaction。</p>
</li>
<li><p>这是因为，最开始我构造 MPO 时默认 9 个矩阵都是一样的，或者说相互作用是有平移对称的。但是注意到</p>
<p>  $\langle i, j\rangle_H \in(0,3),(3,6),(1,4),(4,7),(2,5),(5,8)$</p>
<p>  $\langle i, j\rangle_V \in(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(6,7),(7,8),(8,6)$</p>
<p>  这里可以做个分类，分为“近邻”相互作用，“次近邻”相互作用，“次次近邻”相互作用（引号表示不是物理意义上的近邻，而是标号意义上的）：</p>
<p>  $\underline{(0,1)}\ \underline{(1,2)}\ (2,3)\ \underline{(3,4)}\ \underline{(4,5)}\ (5,6)\ …$</p>
<p>  $\underline{(0,2)}\ (1,3)\ (2,4)\ \underline{(3,5)}\ (4,6)\ (5,7)\ …$</p>
<p>  $\underline{(0,3)}\ \underline{(1,4)}\ \underline{(2,5)}\ \underline{(3,6)}\ \underline{(4,7)}\ \underline{(5,8)}\ $</p>
<p>  下划线表示 compass model 中存在的相互作用。可以见得，Sx 相关项是“次次近邻”相互作用，平移对称完备；Sy 相关项“近邻”相互作用，“次近邻”相互作用并不是完备的。如果“构造 MPO 时默认 9 个矩阵都是一样”，显然没法反应这种 site 间的不同性，或者说 MPO 构造时没考虑 H,V 显然不合理。</p>
</li>
<li><p>解决方法：</p>
<p>  显然地有两种思路解决：</p>
<ol>
<li><p>考虑这种 site 间的不等价性，先画 finite automata figure， 对应地写出不同 site 间的 MPO（最后用下文中的 <em>MPO generate Hamiltonian OP</em> 来看生成的哈密顿量是否正确）；</p>
</li>
<li><p>针对 compass model， 注意到 Sx 相关的 N 个 MPO 是相等的，这是因为“次次近邻”相互作用是完备的；那么，如果我重新定义下标，即原来的 “036147258” 定义为 “012345678”，可以发现这时候 Sy 相关的 $<i,j>_{V}$ 完备，也就是说可以写成 N 个相等的 MPO。原有的哈密顿量 H 可以分成 H_{x} 和 H_{y}, 分别拆成 N 个相同的 MPO_{x} 或者 MPO_{y} 相乘。</p>
<p>考虑到后续的简单 MPS 算法，本文后续沿用第一个思路，即生成 N 个不同的 MPO。</p>
</li>
</ol>
</li>
</ul>
<font size =4> Question 1 </font>

<ul>
<li><p>如下图所示，可见 $D = 6$</p>
  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/06/D9RkN7M8Y4oPayK.png style="zoom:60%" />   
  </div>

  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/06/PpdcK78Wsi65mtu.png style="zoom:60%" />   
  </div>
</li>
<li><p>根据上面的 automata figure 得到 MPOs：</p>
</li>
</ul>
<script type="math/tex; mode=display">
\left(\begin{array}{llll}
I & -J_{x}\sigma^{x} & -J_{y}\sigma^{y} & h_{z}\sigma^{z}
\end{array}\right)\left(\begin{array}{ccccc}
I & -J_{x}\sigma^{x} & 0 & -J_{y}\sigma^{y} & h_{z}\sigma^{z} \\
0 & 0 & I & 0 & 0 \\
0 & 0 & 0 & I & \sigma^{y} \\
0 & 0 & 0 & 0 & I
\end{array}\right)\left(\begin{array}{ccccc}
I & -J_{x}\sigma^{x} & 0 & 0 & h_{z}\sigma^{z} \\
0 & 0 & I & 0 & 0 \\
0 & 0 & 0 & I & 0 \\
0 & 0 & 0 & 0 & \sigma^{y} \\
0 & 0 & 0 & 0 & I
\end{array}\right)</script><script type="math/tex; mode=display">
\left(\begin{array}{cccccc}
I & -J_{x}\sigma^{x} & 0 & 0 &  -J_{y}\sigma^{y} & h_{z}\sigma^{z} \\
0 & 0 & I & 0 & 0 & 0\\
0 & 0 & 0 & I & 0 & 0\\
0 & 0 & 0 & 0 & 0 & \sigma^{x}\\
0 & 0 & 0 & 0 &  0 & I
\end{array}\right)\left(\begin{array}{cccccc}
I & -J_{x}\sigma^{x} & 0 & 0 &  -J_{y}\sigma^{y} & h_{z}\sigma^{z} \\
0 & 0 & I & 0 & 0 & 0\\
0 & 0 & 0 & I & 0 & 0\\
0 & 0 & 0 & 0 & 0 & \sigma^{x}\\
0 & 0 & 0 & 0 & I & \sigma^{y}\\
0 & 0 & 0 & 0 &  0 & I
\end{array}\right)\left(\begin{array}{ccccc}
I & -J_{x}\sigma^{x} & 0 & 0 & h_{z}\sigma^{z} \\
0 & 0 & I & 0 & 0 \\
0 & 0 & 0 & I & 0 \\
0 & 0 & 0 & 0 & \sigma^{x} \\
0 & 0 & 0 & 0 & \sigma^{y} \\
0 & 0 & 0 & 0 & I
\end{array}\right)</script><script type="math/tex; mode=display">
\left(\begin{array}{ccccc}
I & 0 & 0 & -J_{y}\sigma^{y} & h_{z}\sigma^{z} \\
0 & I & 0 & 0 & 0\\
0 & 0 & I & 0 & 0\\
0 & 0 & 0 & 0 & \sigma^{x}\\
0 & 0 & 0 & 0 & I
\end{array}\right)\left(\begin{array}{cccc}
I & 0 &  -J_{y}\sigma^{y} & h_{z}\sigma^{z} \\
0 & I & 0 & 0 \\
0 & 0 & 0 & \sigma^{x}\\
0 & 0 & I & \sigma^{y}\\
0 & 0 & 0 & I
\end{array}\right)\left(\begin{array}{c}
h_{z}\sigma^{z} \\
\sigma^{x} \\
\sigma^{y} \\
I
\end{array}\right)</script><font size =4> Question 2 </font>

<ul>
<li><p><em>MPO generate Hamiltonian OP</em> 程序如下，分成了两部分：1.Operator Expression ; 2.Matrix and eigenvalues</p>
</li>
<li><p>Operator Expression 代码部分实现的是将上述的 MPO 相乘，得到哈密顿量的算符形式表达，验证 MPO 正确性</p>
</li>
<li><p>Matrix and eigenvalues 代码部分是将哈密顿量矩阵写出来，并求20个本征值</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MPO generate Hamiltonian OP -- Operator Expression </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">N = <span class="number">9</span></span><br><span class="line">D = <span class="number">6</span></span><br><span class="line">row = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">col = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OPdot</span>(<span class="params">La,Lb</span>):                                   <span class="comment">#算符作为字符串存储起来，乘积对应字符串加法</span></span><br><span class="line">    Lc = []</span><br><span class="line">    <span class="keyword">for</span> str1 <span class="keyword">in</span> La:</span><br><span class="line">        <span class="keyword">for</span> str2 <span class="keyword">in</span> Lb:</span><br><span class="line">            Lc.append(str1+str2)</span><br><span class="line">    <span class="keyword">return</span> Lc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mply</span>(<span class="params">A,B</span>):                                      <span class="comment">#mply(A,B) 返回 矩阵 C = A*B</span></span><br><span class="line">    II = <span class="built_in">len</span>(A)                                      </span><br><span class="line">    JJ = <span class="built_in">len</span>(B[<span class="number">0</span>])</span><br><span class="line">    KK = <span class="built_in">len</span>(B)</span><br><span class="line">    C = [[[] <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(JJ)] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(II)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(II):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(JJ):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(KK):</span><br><span class="line">                <span class="keyword">if</span>(A[i][k] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> B[k][j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">                    C[i][j] += OPdot(A[i][k],B[k][j])</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"></span><br><span class="line">MPO = []                                               <span class="comment">#MPS存储这9个矩阵，根据Q1的自动机图示来赋值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    M = [[<span class="literal">None</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(col[i])] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(row[i])]</span><br><span class="line">    MPO.append(M)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    MPO[i][<span class="number">0</span>][<span class="number">1</span>] = [<span class="string">&quot;-JxSx &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    MPO[i][<span class="number">0</span>][col[i]-<span class="number">1</span>] = [<span class="string">&quot;hzSz &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">    MPO[i][<span class="number">0</span>][col[i]-<span class="number">2</span>] = [<span class="string">&quot;-JySy &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]:</span><br><span class="line">    MPO[i][row[i]-<span class="number">2</span>][col[i]-<span class="number">1</span>] = [<span class="string">&quot;Sy &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">6</span>]:</span><br><span class="line">    MPO[i][row[i]-<span class="number">2</span>][col[i]-<span class="number">1</span>] = [<span class="string">&quot;Sx &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]:</span><br><span class="line">    MPO[i][row[i]-<span class="number">3</span>][col[i]-<span class="number">1</span>] = [<span class="string">&quot;Sx &quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    MPO[i][<span class="number">0</span>][<span class="number">0</span>] = [<span class="string">&quot;I &quot;</span>]</span><br><span class="line">    MPO[i+<span class="number">1</span>][row[i+<span class="number">1</span>]-<span class="number">1</span>][col[i+<span class="number">1</span>]-<span class="number">1</span>] = [<span class="string">&quot;I &quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">        MPO[i][<span class="number">1</span>][<span class="number">2</span>] = MPO[i][<span class="number">2</span>][<span class="number">3</span>] = [<span class="string">&quot;I &quot;</span>]</span><br><span class="line">MPO[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>] = MPO[<span class="number">6</span>][<span class="number">1</span>][<span class="number">1</span>] = MPO[<span class="number">6</span>][<span class="number">2</span>][<span class="number">2</span>] = MPO[<span class="number">7</span>][<span class="number">1</span>][<span class="number">1</span>] = MPO[<span class="number">7</span>][<span class="number">3</span>][<span class="number">2</span>] = [<span class="string">&quot;I &quot;</span>]</span><br><span class="line"></span><br><span class="line">ANS = MPO[<span class="number">0</span>]                                                    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>):                                                <span class="comment">#将 MPO 乘起来</span></span><br><span class="line">    ANS = mply(ANS,MPO[i+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ANS[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>I I I I I I I I hzSz 
I I I I I -JxSx I I Sx 
I I I I I I I -JySy Sy 
I I I I I I -JySy I Sy 
I I I I I I I hzSz I 
I I I I -JxSx I I Sx I 
I I I I I I -JySy Sy I 
I I I I I I hzSz I I 
I I I -JxSx I I Sx I I 
I I I I I hzSz I I I 
I I -JxSx I I Sx I I I 
I I I I -JySy Sy I I I 
I I I -JySy I Sy I I I 
I I I I hzSz I I I I 
I -JxSx I I Sx I I I I 
I I I -JySy Sy I I I I 
I I I hzSz I I I I I 
-JxSx I I Sx I I I I I 
I I hzSz I I I I I I 
I -JySy Sy I I I I I I 
-JySy I Sy I I I I I I 
I hzSz I I I I I I I 
-JySy Sy I I I I I I I 
hzSz I I I I I I I I 
</code></pre><ul>
<li><p>共有 24 项，分别对应 x, y, z 项数为 6 + 9 + 9 = 24</p>
</li>
<li><p>和 compass model Hamiltonian 比较相一致，说明 MPOs 合理</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MPO generate Hamiltonian OP -- Matrix and eigenvalues</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LA</span><br><span class="line">N = <span class="number">9</span></span><br><span class="line">D = <span class="number">6</span></span><br><span class="line">row = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">col = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Jx = <span class="number">0.3</span></span><br><span class="line">Jy = <span class="number">1.4</span></span><br><span class="line">hz = <span class="number">0.5</span></span><br><span class="line">Sx = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">Sy = [[<span class="number">0</span>, -<span class="number">1.0j</span>], [<span class="number">1.0j</span>, <span class="number">0</span>]]</span><br><span class="line">Sz = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line">O = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">I = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">_JxSx = [[<span class="number">0</span>, -Jx], [-Jx, <span class="number">0</span>]]</span><br><span class="line">_JySy = [[<span class="number">0</span>, -<span class="number">1.0j</span> * -Jy], [<span class="number">1.0j</span> * -Jy, <span class="number">0</span>]]</span><br><span class="line">hzSz = [[hz, <span class="number">0</span>], [<span class="number">0</span>, -hz]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OPdot</span>(<span class="params">La,Lb</span>):                                   <span class="comment">#做直积操作</span></span><br><span class="line">    <span class="keyword">return</span> np.kron(La,Lb)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mply</span>(<span class="params">A,B</span>):                                      <span class="comment">#mply(A,B) 返回 矩阵 C = A*B</span></span><br><span class="line">    II = <span class="built_in">len</span>(A)                                      </span><br><span class="line">    JJ = <span class="built_in">len</span>(B[<span class="number">0</span>])</span><br><span class="line">    KK = <span class="built_in">len</span>(B)</span><br><span class="line">    C = [[<span class="literal">None</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(JJ)] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(II)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(II):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(JJ):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(KK):</span><br><span class="line">                <span class="keyword">if</span> (C[i][j] <span class="keyword">is</span> <span class="literal">None</span>):               <span class="comment"># 判断 None 是为了方便数据类型不出问题</span></span><br><span class="line">                    C[i][j] = OPdot(A[i][k],B[k][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    C[i][j] = C[i][j] + OPdot(A[i][k],B[k][j])</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"></span><br><span class="line">MPO = []                                               <span class="comment">#MPS存储这9个矩阵，根据 Q1 的自动机图示来赋值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    M = [[<span class="literal">None</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(col[i])] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(row[i])]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(row[i]):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(col[i]):</span><br><span class="line">            M[r][c] = O</span><br><span class="line">    MPO.append(M)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    MPO[i][<span class="number">0</span>][<span class="number">1</span>] = _JxSx</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    MPO[i][<span class="number">0</span>][col[i]-<span class="number">1</span>] = hzSz</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">    MPO[i][<span class="number">0</span>][col[i]-<span class="number">2</span>] = _JySy</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]:</span><br><span class="line">    MPO[i][row[i]-<span class="number">2</span>][col[i]-<span class="number">1</span>] = Sy</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">6</span>]:</span><br><span class="line">    MPO[i][row[i]-<span class="number">2</span>][col[i]-<span class="number">1</span>] = Sx</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]:</span><br><span class="line">    MPO[i][row[i]-<span class="number">3</span>][col[i]-<span class="number">1</span>] = Sx</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    MPO[i][<span class="number">0</span>][<span class="number">0</span>] = I</span><br><span class="line">    MPO[i+<span class="number">1</span>][row[i+<span class="number">1</span>]-<span class="number">1</span>][col[i+<span class="number">1</span>]-<span class="number">1</span>] = I</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">        MPO[i][<span class="number">1</span>][<span class="number">2</span>] = MPO[i][<span class="number">2</span>][<span class="number">3</span>] = I</span><br><span class="line">MPO[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>] = MPO[<span class="number">6</span>][<span class="number">1</span>][<span class="number">1</span>] = MPO[<span class="number">6</span>][<span class="number">2</span>][<span class="number">2</span>] = MPO[<span class="number">7</span>][<span class="number">1</span>][<span class="number">1</span>] = MPO[<span class="number">7</span>][<span class="number">3</span>][<span class="number">2</span>] = I</span><br><span class="line"></span><br><span class="line">ANS = MPO[<span class="number">0</span>]                                                </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>):                                                <span class="comment">#将 MPO 乘起来</span></span><br><span class="line">    ANS = mply(ANS,MPO[i+<span class="number">1</span>])</span><br><span class="line">ANS = np.real(ANS)</span><br><span class="line"><span class="built_in">print</span>(ANS[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">E,W = LA.eigsh(ANS[<span class="number">0</span>][<span class="number">0</span>],<span class="number">20</span>,which = <span class="string">&#x27;SA&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(E)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 4.5  0.   0.  ...  0.   0.   0. ]
 [ 0.   3.5 -1.4 ...  0.   0.   0. ]
 [ 0.  -1.4  3.5 ...  0.   0.   0. ]
 ...
 [ 0.   0.   0.  ... -3.5 -1.4  0. ]
 [ 0.   0.   0.  ... -1.4 -3.5  0. ]
 [ 0.   0.   0.  ...  0.   0.  -4.5]]
[-13.12646931 -13.07866474 -13.07575853 -13.06893675 -13.03230613
 -13.02946844 -13.02304559 -12.9880016   -8.68300191  -8.56677243
  -8.56586155  -8.37964052  -8.37964052  -8.26479657  -8.23663151
  -8.23248641  -8.2288993   -8.21755532  -8.21755532  -8.21213607]
</code></pre><ul>
<li>作为对比，精确对角化如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LA</span><br><span class="line"></span><br><span class="line">Jx = <span class="number">0.3</span></span><br><span class="line">Jy = <span class="number">1.4</span></span><br><span class="line">hz = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">9</span></span><br><span class="line">n = <span class="number">1</span>&lt;&lt;N</span><br><span class="line"></span><br><span class="line">H_Near = [(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">6</span>),(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">7</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">8</span>)]</span><br><span class="line">V_Near = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">3</span>),(<span class="number">6</span>,<span class="number">7</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">8</span>,<span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FlipBit</span>(<span class="params">i,n</span>):</span><br><span class="line">    <span class="keyword">return</span> i^(<span class="number">1</span>&lt;&lt;n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReadBit</span>(<span class="params">i,n</span>):</span><br><span class="line">    <span class="keyword">return</span> (i&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n</span><br><span class="line"></span><br><span class="line">H = np.zeros([n,n])</span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> (i,j) <span class="keyword">in</span> H_Near:</span><br><span class="line">        res = FlipBit( FlipBit(state,j) ,i)</span><br><span class="line">        H[state][res] = - Jx</span><br><span class="line">    <span class="keyword">for</span> (i,j) <span class="keyword">in</span> V_Near:</span><br><span class="line">        res = FlipBit( FlipBit(state,j) ,i)</span><br><span class="line">        flag = ReadBit(state, i) ^ ReadBit(state, j) </span><br><span class="line">        H[state][res] = - Jy <span class="keyword">if</span> flag == <span class="number">1</span> <span class="keyword">else</span> Jy</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        flag = ReadBit(state, i)</span><br><span class="line">        H[state][state] +=  hz <span class="keyword">if</span> flag == <span class="number">1</span> <span class="keyword">else</span> -hz</span><br><span class="line"><span class="built_in">print</span>(H)</span><br><span class="line">E,W = LA.eigsh(H,<span class="number">20</span>,which = <span class="string">&#x27;SA&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(E)</span><br></pre></td></tr></table></figure>
<pre><code>[[-4.5  0.   0.  ...  0.   0.   0. ]
 [ 0.  -3.5 -1.4 ...  0.   0.   0. ]
 [ 0.  -1.4 -3.5 ...  0.   0.   0. ]
 ...
 [ 0.   0.   0.  ...  3.5 -1.4  0. ]
 [ 0.   0.   0.  ... -1.4  3.5  0. ]
 [ 0.   0.   0.  ...  0.   0.   4.5]]
[-13.12646931 -13.07866474 -13.07575853 -13.06893675 -13.03230613
 -13.02946844 -13.02304559 -12.9880016   -8.68300191  -8.56677243
  -8.56586155  -8.37964052  -8.37964052  -8.26479657  -8.23663151
  -8.23248641  -8.2288993   -8.21755532  -8.21755532  -8.21213607]
</code></pre><ul>
<li>比较发现，MPO 相乘得到的哈密顿量矩阵和前 20 个特征值，与 ED 得到的结果一致。</li>
</ul>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>2-site variational MPS method in 1D spin model</title>
    <url>/2022/11/13/HW_MPS1107/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size = 5> Homework </font>

<ul>
<li>read and understand the sample code 1-site variational MPS method</li>
<li>consider the 1D spin model with open boundary condition</li>
</ul>
<script type="math/tex; mode=display">
H=-\sum_j\left(\sigma_{j-1}^z \sigma_j^y \sigma_{j+1}^z+\sigma_j^x\right)</script><ul>
<li><p>write a code for the 2-site variational MPS method</p>
<p>  choose $N = 10$ , $D_{s} = 4 , 6 $, calculate the ground state energy $E$ per site, and the magnetization per site $\left\langle\sigma_i^z\right\rangle$ and $\left\langle\sigma_i^x\right\rangle$</p>
<p>  compare with the results obtained from exact diagonalization</p>
</li>
<li><font size = 4> a brief summary of theory and algorithm </font>

<p>  sample code 主要步骤如下：</p>
<ol>
<li><p>write Hamiltonian as an MPO</p>
</li>
<li><p>tensor initialization</p>
</li>
<li><p>environment initialization</p>
</li>
<li><p>sweep back and forth to optimize each tensor</p>
<p>对于给定的 1 D spin model，注意到其包括两部分：相邻三体和单体。（除去端点处）有平移对称性，MPO 如下:</p>
<script type="math/tex; mode=display">
\left(\begin{array}{cccc}
I & -\sigma^{z} & 0 & -\sigma^{x} \\
0 & 0 & \sigma^{y} & 0 \\
0 & 0 & 0 & \sigma^{z} \\
0 & 0 & 0 & I
\end{array}\right)</script><p>端点处（site0 和 site9）的 MPO ：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{cccc}
I & 0 & 0 & -\sigma^{x} \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & I
\end{array}\right)</script><p>下面的 code 中近似地忽略端点处的 MPO，这一点与后面的 Exact solution 对比可以发现这种近似的精度是合理的。 </p>
<p>张量和环境的初始化和 1-site 的类似，这里主要讨论 2-site 的 sweep 如何实现。</p>
<div  align="center">    
<img src=https://s2.loli.net/2022/11/13/F3gIuawYMWZERi9.png style="zoom:70%" />   
</div>



</li>
</ol>
</li>
</ul>
<p>optimize two sites : 一次将两个相邻的 T 相乘，作 SVD 分解。对于向右 sweep 的过程，将分解得到的 U 作为新的 T[i] ，得到的 S 和 V 相乘作为新的 T[i+1] ，如此继续循环；对于向左的 sweep 过程同理。 其中要注意的是分解的 U，S，V 需要根据原来的 T[i] 和 T[i+1] 之间耦合的维度 Dcut 做截断。</p>
<p>code 中 NCon 的 index 对应如下：</p>
<div  align="center">    
<img src=https://s2.loli.net/2022/11/13/YagrZSJl45khiX2.jpg style="zoom:30%" />   
</div>    


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> LA</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LAs</span><br><span class="line"><span class="keyword">import</span> Sub180221 <span class="keyword">as</span> Sub</span><br><span class="line"><span class="keyword">import</span> math,copy</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Mi =</span></span><br><span class="line"><span class="string">s0	-sz	0	-sx</span></span><br><span class="line"><span class="string">0	0	sy	0</span></span><br><span class="line"><span class="string">0	0	0	sz</span></span><br><span class="line"><span class="string">0	0	0	s0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetMpo_Heisenberg_Obc</span>(<span class="params">Dp</span>):									<span class="comment">#生成 MPO</span></span><br><span class="line">	S0,Sp,Sm,Sz,Sx,Sy = Sub.SpinOper(Dp)</span><br><span class="line">	</span><br><span class="line">	Dmpo = <span class="number">4</span></span><br><span class="line">	Mpo = np.zeros((Dmpo,Dp,Dmpo,Dp),dtype = <span class="built_in">complex</span>)</span><br><span class="line">	</span><br><span class="line">	Mpo[<span class="number">0</span>,:,<span class="number">0</span>,:] = S0</span><br><span class="line">	Mpo[<span class="number">0</span>,:,<span class="number">1</span>,:] = -<span class="number">2</span> * Sz</span><br><span class="line">	Mpo[<span class="number">0</span>,:,<span class="number">3</span>,:] = -<span class="number">2</span> * Sx</span><br><span class="line">	Mpo[<span class="number">1</span>,:,<span class="number">2</span>,:] = <span class="number">2</span> * Sy</span><br><span class="line">	Mpo[<span class="number">2</span>,:,<span class="number">3</span>,:] = <span class="number">2</span> * Sz</span><br><span class="line">	Mpo[<span class="number">3</span>,:,<span class="number">3</span>,:] = S0</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Mpo</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">InitMps</span>(<span class="params">Ns,Dp,Ds</span>):											<span class="comment">#初始化 MPS</span></span><br><span class="line">	T = [<span class="literal">None</span>]*Ns</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns):</span><br><span class="line">		Dl = <span class="built_in">min</span>(Dp**i,Dp**(Ns-i),Ds)</span><br><span class="line">		Dr = <span class="built_in">min</span>(Dp**(i+<span class="number">1</span>),Dp**(Ns-<span class="number">1</span>-i),Ds)</span><br><span class="line">		T[i] = np.random.rand(Dl,Dp,Dr)</span><br><span class="line">	U = np.eye(np.shape(T[-<span class="number">1</span>])[-<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">		U,T[i] = Sub.Mps_LQP(T[i],U)</span><br><span class="line">	<span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">InitH</span>(<span class="params">Mpo,T</span>):												<span class="comment">#初始化环境 HL HR</span></span><br><span class="line">	Ns = <span class="built_in">len</span>(T)</span><br><span class="line">	Dmpo = np.shape(Mpo)[<span class="number">0</span>]</span><br><span class="line">	HL = [<span class="literal">None</span>]*Ns</span><br><span class="line">	HR = [<span class="literal">None</span>]*Ns</span><br><span class="line">	HL[<span class="number">0</span>] = np.zeros((<span class="number">1</span>,Dmpo,<span class="number">1</span>))</span><br><span class="line">	HL[<span class="number">0</span>][<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	HR[-<span class="number">1</span>] = np.zeros((<span class="number">1</span>,Dmpo,<span class="number">1</span>))</span><br><span class="line">	HR[-<span class="number">1</span>][<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">		HR[i-<span class="number">1</span>] = Sub.NCon([HR[i],T[i],Mpo,np.conj(T[i])],[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[-<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[-<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">	<span class="keyword">return</span> HL,HR</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OptTSite</span>(<span class="params">Mpo,HL,HR,T,Method=<span class="number">0</span></span>):								<span class="comment">#2-site的 OptTSite，这里的 T 其实是相邻两个 site 的 T 的积</span></span><br><span class="line">	DT = np.shape(T)</span><br><span class="line">	<span class="keyword">if</span> Method == <span class="number">0</span>:</span><br><span class="line">		A = Sub.NCon([HL,Mpo,Mpo,HR],[[-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">5</span>],[<span class="number">1</span>,-<span class="number">6</span>,<span class="number">2</span>,-<span class="number">2</span>],[<span class="number">2</span>,-<span class="number">7</span>,<span class="number">3</span>,-<span class="number">3</span>],[-<span class="number">8</span>,<span class="number">3</span>,-<span class="number">4</span>]])</span><br><span class="line">		A = Sub.Group(A,[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]])</span><br><span class="line">		Eig,V = LAs.eigsh(A,k=<span class="number">1</span>,which=<span class="string">&#x27;SA&#x27;</span>)</span><br><span class="line">		T = np.reshape(V,(DT[<span class="number">0</span>]*DT[<span class="number">1</span>],DT[<span class="number">2</span>]*DT[<span class="number">3</span>]))        		<span class="comment">#V reshape 成四阶张量 T</span></span><br><span class="line">	<span class="keyword">return</span> T,Eig</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OptT</span>(<span class="params">Mpo,HL,HR,T</span>):</span><br><span class="line">	Ns = <span class="built_in">len</span>(T)</span><br><span class="line">	Eng0 = np.zeros(Ns)</span><br><span class="line">	Eng1 = np.zeros(Ns)</span><br><span class="line">	<span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">		<span class="built_in">print</span>(r)</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns-<span class="number">1</span>):									<span class="comment"># 向右 sweep</span></span><br><span class="line">			temp,Eng1[i] = OptTSite(Mpo,HL[i],HR[i+<span class="number">1</span>],np.tensordot(T[i],T[i+<span class="number">1</span>],(<span class="number">2</span>,<span class="number">0</span>)),Method=<span class="number">0</span>)	<span class="comment">#T[i]*T[i+1]作为新的张量传过去</span></span><br><span class="line">			Dcut = np.shape(T[i])[<span class="number">2</span>]								<span class="comment"># Dcut 是截断维数</span></span><br><span class="line">			U,S,V = LA.svd(temp,full_matrices=<span class="number">0</span>)</span><br><span class="line">			U = U[:,<span class="number">0</span>:Dcut]</span><br><span class="line">			S = S[<span class="number">0</span>:Dcut]</span><br><span class="line">			V = V[<span class="number">0</span>:Dcut,:]</span><br><span class="line">			T[i] = np.reshape(U,np.shape(T[i]))					<span class="comment">#更新 T[i],T[i+1],HL[i+1]</span></span><br><span class="line">			SV = np.dot(np.diag(S),V)</span><br><span class="line">			T[i+<span class="number">1</span>] = np.reshape(SV,np.shape(T[i+<span class="number">1</span>]))</span><br><span class="line">			HL[i+<span class="number">1</span>] = Sub.NCon([HL[i],np.conj(T[i]),Mpo,T[i]],[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,-<span class="number">2</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">4</span>,-<span class="number">3</span>]])</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):								<span class="comment"># 向左 sweep</span></span><br><span class="line">			temp,Eng1[i] = OptTSite(Mpo,HL[i-<span class="number">1</span>],HR[i],np.tensordot(T[i-<span class="number">1</span>],T[i],(<span class="number">2</span>,<span class="number">0</span>)),Method=<span class="number">0</span>)	<span class="comment">#T[i-1]*T[i]作为新的张量传过去</span></span><br><span class="line">			Dcut = np.shape(T[i])[<span class="number">0</span>]								<span class="comment"># Dcut 是截断维数</span></span><br><span class="line">			U,S,V = LA.svd(temp,full_matrices=<span class="number">0</span>)</span><br><span class="line">			U = U[:,<span class="number">0</span>:Dcut]</span><br><span class="line">			S = S[<span class="number">0</span>:Dcut]</span><br><span class="line">			V = V[<span class="number">0</span>:Dcut,:]</span><br><span class="line">			T[i] = np.reshape(V,np.shape(T[i]))					<span class="comment">#更新 T[i],T[i-1],HR[i-1]</span></span><br><span class="line">			US = np.dot(U,np.diag(S))</span><br><span class="line">			T[i-<span class="number">1</span>] = np.reshape(US,np.shape(T[i-<span class="number">1</span>]))</span><br><span class="line">			HR[i-<span class="number">1</span>] = Sub.NCon([HR[i],T[i],Mpo,np.conj(T[i])],[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[-<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[-<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(Eng1)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">abs</span>(Eng1[<span class="number">1</span>]-Eng0[<span class="number">1</span>]) &lt; <span class="number">1.0e-7</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		Eng0 = copy.copy(Eng1)</span><br><span class="line">	<span class="built_in">print</span>(Eng1/<span class="built_in">float</span>(Ns))</span><br><span class="line">	<span class="keyword">return</span> T,Eng1/<span class="built_in">float</span>(Ns)</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	Ns = <span class="number">10</span></span><br><span class="line">	Dp = <span class="number">2</span></span><br><span class="line">	Ds = [<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">	Answer = []</span><br><span class="line"></span><br><span class="line">	Mpo = GetMpo_Heisenberg_Obc(Dp)</span><br><span class="line">	<span class="keyword">for</span> ds <span class="keyword">in</span> Ds:</span><br><span class="line">		T = InitMps(Ns,Dp,ds)</span><br><span class="line">		HL,HR = InitH(Mpo,T)</span><br><span class="line">		T,E= OptT(Mpo,HL,HR,T)</span><br><span class="line">		GS = T[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns-<span class="number">1</span>):</span><br><span class="line">			GS = np.tensordot(GS,T[i+<span class="number">1</span>],(i+<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">		GS = np.reshape(GS,(<span class="number">1024</span>,<span class="number">1</span>))</span><br><span class="line">		Answer.append((ds,E,GS))</span><br></pre></td></tr></table></figure>
<pre><code>0
[ -9.94119199 -11.48599436 -11.48599436 -11.48641231 -11.48638648
 -11.48628296 -11.4859645  -11.48480444 -11.4844155  -11.4844155 ]
1
[-11.48599436 -11.48597508 -11.48597508 -11.48639425 -11.48660135
 -11.48666644 -11.48660205 -11.48639534 -11.48597623 -11.48597623]
2
[-11.48597508 -11.48597502 -11.48597502 -11.4863942  -11.48660113
 -11.48666585 -11.48660113 -11.4863942  -11.48597503 -11.48597503]
[-1.14859751 -1.1485975  -1.1485975  -1.14863942 -1.14866011 -1.14866659
 -1.14866011 -1.14863942 -1.1485975  -1.1485975 ]
0
[-10.09613213 -11.48870684 -11.48870684 -11.48878776 -11.4888277
 -11.48872879 -11.48838718 -11.48821485 -11.48813509 -11.48813509]
1
[-11.48870684 -11.48870695 -11.48870695 -11.48878788 -11.48886592
 -11.48888725 -11.48886592 -11.48878788 -11.48870695 -11.48870695]
2
[-11.48870695 -11.48870695 -11.48870695 -11.48878788 -11.48886592
 -11.48888725 -11.48886592 -11.48878788 -11.48870695 -11.48870695]
[-1.14887069 -1.14887069 -1.14887069 -1.14887879 -1.14888659 -1.14888873
 -1.14888659 -1.14887879 -1.14887069 -1.14887069]
</code></pre><ul>
<li><p>这里的列表 Answer = [(ds,E,GS)] 分别储存的截断 Ds，基态能量 per site E，以及 groud state GS。 </p>
</li>
<li><p>下面计算 $D_{s} = 4 , 6 $ 情况下的 ： 1. ground state energy $E$ per site； 2. magnetization per site $\left\langle\sigma_i^z\right\rangle$ and $\left\langle\sigma_i^x\right\rangle$</p>
</li>
<li><p>先定义计算磁化强度的 mag_x 和 mag_z 函数：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">FlipBit</span>(<span class="params">i,n</span>):</span><br><span class="line">    <span class="keyword">return</span> i^(<span class="number">1</span>&lt;&lt;n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReadBit</span>(<span class="params">i,n</span>):</span><br><span class="line">    <span class="keyword">return</span> (i&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mag_z</span>(<span class="params">W</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;z:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns):</span><br><span class="line">        SzW = np.zeros(<span class="number">1024</span>,dtype = <span class="built_in">complex</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = <span class="number">1</span>&lt;&lt;Ns</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sign = <span class="number">1</span> <span class="keyword">if</span> ReadBit(state, i) == <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            SzW[state] = sign * W[state]</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res = res + np.conj(W)[state] * SzW[state]</span><br><span class="line">        <span class="built_in">print</span>(i,np.real(res))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mag_x</span>(<span class="params">W</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ns):</span><br><span class="line">        SxW = np.zeros(<span class="number">1024</span>,dtype = <span class="built_in">complex</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = <span class="number">1</span>&lt;&lt;Ns</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            SxW[FlipBit(state,i)] =  W[state]</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res = res + np.conj(W)[state] * SxW[state]</span><br><span class="line">        <span class="built_in">print</span>(i,np.real(res))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>对于 Ds = 4：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ds=&quot;</span>+<span class="built_in">str</span>(Answer[<span class="number">0</span>][<span class="number">0</span>])+<span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ground state energy E per site:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Answer[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;magnetization per site &lt;sigma^z&gt; and &lt;sigma^x&gt;:&quot;</span>)</span><br><span class="line">mag_z(Answer[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">mag_x(Answer[<span class="number">0</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<pre><code>Ds=4:
ground state energy E per site:
[-1.14859751 -1.1485975  -1.1485975  -1.14863942 -1.14866011 -1.14866659
 -1.14866011 -1.14863942 -1.1485975  -1.1485975 ]
magnetization per site &lt;sigma^z&gt; and &lt;sigma^x&gt;:
z:
0 [7.21557529e-09]
1 [-9.58418942e-09]
2 [-5.03324422e-09]
3 [2.40059455e-09]
4 [-1.82414969e-09]
5 [-2.32618917e-09]
6 [1.5960039e-09]
7 [-2.92614971e-09]
8 [-2.37970759e-09]
9 [1.22052863e-09]
x:
0 [0.9173015]
1 [0.84768239]
2 [0.78414904]
3 [0.7604599]
4 [0.75185056]
5 [0.75202071]
6 [0.76080662]
7 [0.78431687]
8 [0.84831043]
9 [0.91792175]
</code></pre><ul>
<li>对于 Ds = 6:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ds=&quot;</span>+<span class="built_in">str</span>(Answer[<span class="number">1</span>][<span class="number">0</span>])+<span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ground state energy E per site:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Answer[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;magnetization per site &lt;sigma^z&gt; and &lt;sigma^x&gt;:&quot;</span>)</span><br><span class="line">mag_z(Answer[<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line">mag_x(Answer[<span class="number">1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<pre><code>Ds=6:
ground state energy E per site:
[-1.14887069 -1.14887069 -1.14887069 -1.14887879 -1.14888659 -1.14888873
 -1.14888659 -1.14887879 -1.14887069 -1.14887069]
magnetization per site &lt;sigma^z&gt; and &lt;sigma^x&gt;:
z:
0 [-1.43079909e-10]
1 [1.24069037e-08]
2 [-6.39897362e-09]
3 [-8.64023536e-10]
4 [9.2880419e-09]
5 [-3.83658105e-09]
6 [-9.85073963e-10]
7 [8.11689286e-09]
8 [-2.77860332e-09]
9 [-2.90920866e-10]
x:
0 [0.91675276]
1 [0.84696303]
2 [0.78332349]
3 [0.76008148]
4 [0.75169612]
5 [0.75168807]
6 [0.76005655]
7 [0.78330731]
8 [0.84695633]
9 [0.91675164]
</code></pre><ul>
<li><p>可见 z 方向 magnetization 约为零， x 方向上有正的 magnetization，在两边的边界处略大于中间。</p>
</li>
<li><p>作为对比，该问题的精确解如下：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Exact diagonalization Solution</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LA</span><br><span class="line"></span><br><span class="line">N = <span class="number">10</span></span><br><span class="line">n = <span class="number">1</span>&lt;&lt;N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FlipBit</span>(<span class="params">i,n</span>):</span><br><span class="line">    <span class="keyword">return</span> i^(<span class="number">1</span>&lt;&lt;n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReadBit</span>(<span class="params">i,n</span>):</span><br><span class="line">    <span class="keyword">return</span> (i&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n</span><br><span class="line"></span><br><span class="line">H = np.zeros([n,n], dtype = <span class="built_in">complex</span>)</span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        res = FlipBit(state, j)</span><br><span class="line">        H[state][res] += -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N-<span class="number">1</span>):</span><br><span class="line">        flag = ReadBit(state, j+<span class="number">1</span>) + ReadBit(state, j) + ReadBit(state, j-<span class="number">1</span>)</span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> flag % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        res = FlipBit(state, j)</span><br><span class="line">        H[state][res] += -<span class="number">1.0j</span> * sign</span><br><span class="line">E,eigenV = LA.eigsh(H,<span class="number">1</span>,which = <span class="string">&#x27;SA&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;exact ground state energy E per site:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(E[<span class="number">0</span>]/N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;magnetization per site &lt;sigma^z&gt; and &lt;sigma^x&gt;:&quot;</span>)</span><br><span class="line">mag_z(eigenV)</span><br><span class="line">mag_x(eigenV)</span><br></pre></td></tr></table></figure>
<pre><code>exact ground state energy E per site:
-1.1489442065958528
magnetization per site &lt;sigma^z&gt; and &lt;sigma^x&gt;:
z:
0 [-4.02022166e-16]
1 [-1.9246757e-15]
2 [2.60815675e-15]
3 [-3.47812057e-16]
4 [-2.47631776e-15]
5 [3.13724741e-15]
6 [-3.0444397e-16]
7 [-2.10855639e-15]
8 [2.42948023e-15]
9 [-3.0444397e-16]
x:
0 [0.91622482]
1 [0.84621457]
2 [0.78255915]
3 [0.75946665]
4 [0.75122694]
5 [0.75122694]
6 [0.75946665]
7 [0.78255915]
8 [0.84621457]
9 [0.91622482]
</code></pre><ul>
<li><p>最后把结果放在这里方便对比：</p>
  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/13/DFUErtflWHhb3Lv.png style="zoom:60%" />  
  <img src=https://s2.loli.net/2022/11/13/BIuGqLTzptO3yr6.png style="zoom:60%" /> 
  <img src=https://s2.loli.net/2022/11/13/JKEgYBLitGrQ2eS.png style="zoom:65%" />  
  </div>



</li>
</ul>
<ul>
<li><p>注：Sub180221.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright:</span></span><br><span class="line"><span class="string">Shuo Yang, shuoyang@tsinghua.edu.cn</span></span><br><span class="line"><span class="string">Nov 1, 2021, Tsinghua, Beijing, China</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> LA</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LAs</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Group</span>(<span class="params">A,shapeA</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; transpose + reshape &quot;&quot;&quot;</span></span><br><span class="line">	dimA = np.asarray(np.shape(A))</span><br><span class="line">	rankA = <span class="built_in">len</span>(shapeA)</span><br><span class="line">	</span><br><span class="line">	shapeB = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,rankA):</span><br><span class="line">		shapeB += [np.prod(dimA[shapeA[i]])]</span><br><span class="line">	</span><br><span class="line">	orderB = <span class="built_in">sum</span>(shapeA,[])</span><br><span class="line">	A = np.reshape(np.transpose(A,orderB),shapeB)</span><br><span class="line">	<span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">NCon</span>(<span class="params">Tensor,Index</span>):</span><br><span class="line">	ConList = <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">max</span>(<span class="built_in">sum</span>(Index,[]))+<span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">len</span>(ConList) &gt; <span class="number">0</span>:</span><br><span class="line">	</span><br><span class="line">		Icon = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Index)):</span><br><span class="line">			<span class="keyword">if</span> ConList[<span class="number">0</span>] <span class="keyword">in</span> Index[i]:</span><br><span class="line">				Icon.append(i)</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(Icon) == <span class="number">2</span>:</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(Icon) == <span class="number">1</span>:</span><br><span class="line">			IndCommon = <span class="built_in">list</span>(<span class="built_in">set</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> Index[Icon[<span class="number">0</span>]] <span class="keyword">if</span> Index[Icon[<span class="number">0</span>]].count(x)&gt;<span class="number">1</span>]))</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> icom <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(IndCommon)):</span><br><span class="line">				Pos = <span class="built_in">sorted</span>([i <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(Index[Icon[<span class="number">0</span>]]) <span class="keyword">if</span> x==IndCommon[icom]])</span><br><span class="line">				Tensor[Icon[<span class="number">0</span>]] = np.trace(Tensor[Icon[<span class="number">0</span>]],axis1=Pos[<span class="number">0</span>],axis2=Pos[<span class="number">1</span>])</span><br><span class="line">				Index[Icon[<span class="number">0</span>]].pop(Pos[<span class="number">1</span>])</span><br><span class="line">				Index[Icon[<span class="number">0</span>]].pop(Pos[<span class="number">0</span>])</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			IndCommon = <span class="built_in">list</span>(<span class="built_in">set</span>(Index[Icon[<span class="number">0</span>]]) &amp; <span class="built_in">set</span>(Index[Icon[<span class="number">1</span>]]))		</span><br><span class="line">			Pos = [[],[]]</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">				<span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(IndCommon)):</span><br><span class="line">					Pos[i].append(Index[Icon[i]].index(IndCommon[ind]))</span><br><span class="line">			A = np.tensordot(Tensor[Icon[<span class="number">0</span>]],Tensor[Icon[<span class="number">1</span>]],(Pos[<span class="number">0</span>],Pos[<span class="number">1</span>]))</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">				<span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(IndCommon)):</span><br><span class="line">					Index[Icon[i]].remove(IndCommon[ind])</span><br><span class="line">			Index[Icon[<span class="number">0</span>]] = Index[Icon[<span class="number">0</span>]]+Index[Icon[<span class="number">1</span>]]</span><br><span class="line">			Index.pop(Icon[<span class="number">1</span>])</span><br><span class="line">			Tensor[Icon[<span class="number">0</span>]] = A</span><br><span class="line">			Tensor.pop(Icon[<span class="number">1</span>])</span><br><span class="line">		</span><br><span class="line">		ConList = <span class="built_in">list</span>(<span class="built_in">set</span>(ConList)^<span class="built_in">set</span>(IndCommon))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">len</span>(Index) &gt; <span class="number">1</span>:</span><br><span class="line">		</span><br><span class="line">		Tensor[<span class="number">0</span>] = np.multiply.outer(Tensor[<span class="number">0</span>],Tensor[<span class="number">1</span>])</span><br><span class="line">		Tensor.pop(<span class="number">1</span>)</span><br><span class="line">		Index[<span class="number">0</span>] = Index[<span class="number">0</span>]+Index[<span class="number">1</span>]</span><br><span class="line">		Index.pop(<span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	Index = Index[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(Index) &gt; <span class="number">0</span>:</span><br><span class="line">		Order = <span class="built_in">sorted</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(Index)),key=<span class="keyword">lambda</span> k:Index[k])[::-<span class="number">1</span>]	</span><br><span class="line">		Tensor = np.transpose(Tensor[<span class="number">0</span>],Order)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		Tensor = Tensor[<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Tensor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SpinOper</span>(<span class="params">ss</span>):</span><br><span class="line">	spin = (ss-<span class="number">1</span>)/<span class="number">2.0</span></span><br><span class="line">	dz = np.zeros(ss)</span><br><span class="line">	mp = np.zeros(ss-<span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ss):</span><br><span class="line">		dz[i] = spin-i</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ss-<span class="number">1</span>):</span><br><span class="line">		mp[i] = np.sqrt((<span class="number">2</span>*spin-i)*(i+<span class="number">1</span>))</span><br><span class="line">	</span><br><span class="line">	S0 = np.eye(ss)</span><br><span class="line">	Sp = np.diag(mp,<span class="number">1</span>)</span><br><span class="line">	Sm = np.diag(mp,-<span class="number">1</span>)</span><br><span class="line">	Sx = <span class="number">0.5</span>*(Sp+Sm)</span><br><span class="line">	Sy = -<span class="number">0.5j</span>*(Sp-Sm)</span><br><span class="line">	Sz = np.diag(dz)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> S0,Sp,Sm,Sz,Sx,Sy</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OutputT</span>(<span class="params">T,prec=<span class="number">1.0e-10</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; output nonzero elements &quot;&quot;&quot;</span></span><br><span class="line">	pos = np.nonzero(np.<span class="built_in">abs</span>(T)&gt;prec)</span><br><span class="line">	val = T[pos]</span><br><span class="line">	pos = np.transpose(pos)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(val)):</span><br><span class="line">		<span class="built_in">print</span>(pos[i],val[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OutputTFile</span>(<span class="params">file,T,prec=<span class="number">1.0e-10</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; output nonzero elements to file &quot;&quot;&quot;</span></span><br><span class="line">	pos = np.nonzero(np.<span class="built_in">abs</span>(T)&gt;prec)</span><br><span class="line">	val = T[pos]</span><br><span class="line">	pos = np.transpose(pos)</span><br><span class="line">	val = np.reshape(val,[<span class="built_in">len</span>(val),<span class="number">1</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> LA.norm(np.imag(T)) &gt; prec:</span><br><span class="line">		out = np.concatenate((pos+<span class="number">1</span>,np.real(val),np.imag(val)),axis=<span class="number">1</span>)</span><br><span class="line">		np.savetxt(file,out,fmt = <span class="string">&#x27;%d\t&#x27;</span>*np.shape(pos)[<span class="number">1</span>] + <span class="string">&#x27;%0.6f \t %0.6f&#x27;</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		out = np.concatenate((pos,np.real(val)),axis=<span class="number">1</span>)</span><br><span class="line">		np.savetxt(file,out,fmt = <span class="string">&#x27;%d\t&#x27;</span>*np.shape(pos)[<span class="number">1</span>] + <span class="string">&#x27;%0.6f&#x27;</span>)</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SplitEig</span>(<span class="params">A,Dcut,prec=<span class="number">1.0e-12</span>,safe=<span class="number">3</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; Eig, Lapack + Arpack &quot;&quot;&quot;</span></span><br><span class="line">	D = np.<span class="built_in">min</span>(np.shape(A))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> Dcut &gt;= D-<span class="number">1</span>:</span><br><span class="line">		S,V = LA.eig(A)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		k_ask = <span class="built_in">min</span>(Dcut+safe,D-<span class="number">2</span>)</span><br><span class="line">		S,V = LAs.eigs(A,k=k_ask)</span><br><span class="line">	</span><br><span class="line">	idx = np.isfinite(S)</span><br><span class="line">	<span class="keyword">if</span> idx.<span class="built_in">any</span>() != <span class="literal">False</span>:</span><br><span class="line">		S = S[idx]</span><br><span class="line">		V = V[:,idx]</span><br><span class="line">	order = np.argsort(<span class="built_in">abs</span>(S))[::-<span class="number">1</span>]</span><br><span class="line">	S = S[order]</span><br><span class="line">	V = V[:,order]</span><br><span class="line">	</span><br><span class="line">	S = S[<span class="built_in">abs</span>(S/S[<span class="number">0</span>])&gt;prec]</span><br><span class="line">	Dc = <span class="built_in">min</span>(<span class="built_in">len</span>(S),Dcut)</span><br><span class="line">	S = S[:Dc]</span><br><span class="line">	V = V[:,:Dc]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> V,S,Dc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SplitEigh</span>(<span class="params">A,Dcut,mode=<span class="string">&#x27;P&#x27;</span>,prec=<span class="number">1.0e-12</span>,safe=<span class="number">3</span>,icheck=<span class="number">0</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; Eig, Hermitian, Lapack + Arpack &quot;&quot;&quot;</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot; P = perserve, C = cut &quot;&quot;&quot;</span></span><br><span class="line">	D = np.<span class="built_in">min</span>(np.shape(A))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> Dcut &gt;= D-<span class="number">1</span>:</span><br><span class="line">		S,V = LA.eigh(A)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		k_ask = <span class="built_in">min</span>(Dcut+safe,D-<span class="number">2</span>)</span><br><span class="line">		S,V = LAs.eigsh(A,k=k_ask)</span><br><span class="line">	</span><br><span class="line">	idx = np.isfinite(S)</span><br><span class="line">	<span class="keyword">if</span> idx.<span class="built_in">any</span>() != <span class="literal">False</span>:</span><br><span class="line">		S = S[idx]</span><br><span class="line">		V = V[:,idx]</span><br><span class="line">	order = np.argsort(<span class="built_in">abs</span>(S))[::-<span class="number">1</span>]</span><br><span class="line">	S = S[order]</span><br><span class="line">	V = V[:,order]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">		S = S[<span class="built_in">abs</span>(S/S[<span class="number">0</span>])&gt;<span class="number">1.0e-15</span>]</span><br><span class="line">		Dc = <span class="built_in">min</span>(<span class="built_in">len</span>(S),Dcut)</span><br><span class="line">		S = S[:Dc]</span><br><span class="line">		V = V[:,:Dc]</span><br><span class="line">		S[<span class="built_in">abs</span>(S/S[<span class="number">0</span>])&lt;prec] = prec*np.sign(S[<span class="built_in">abs</span>(S/S[<span class="number">0</span>])&lt;prec])</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">		S = S[<span class="built_in">abs</span>(S/S[<span class="number">0</span>])&gt;prec]</span><br><span class="line">		Dc = <span class="built_in">min</span>(<span class="built_in">len</span>(S),Dcut)</span><br><span class="line">		S = S[:Dc]</span><br><span class="line">		V = V[:,:Dc]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> icheck == <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(np.dot(V,np.dot(np.diag(S),np.transpose(np.conj(V))))-A)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> V,S,Dc</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SplitSvd_Lapack</span>(<span class="params">A,Dcut,iweight,mode=<span class="string">&#x27;P&#x27;</span>,prec=<span class="number">1.0e-12</span>,icheck=<span class="number">0</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; SVD, Lapack only &quot;&quot;&quot;</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot; P = perserve, C = cut &quot;&quot;&quot;</span></span><br><span class="line">	</span><br><span class="line">	U,S,V = LA.svd(A,full_matrices=<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	S = np.<span class="built_in">abs</span>(S)</span><br><span class="line">	idx = np.isfinite(S)</span><br><span class="line">	<span class="keyword">if</span> idx.<span class="built_in">any</span>() != <span class="literal">False</span>:</span><br><span class="line">		S = S[idx]</span><br><span class="line">		U = U[:,idx]</span><br><span class="line">		V = V[idx,:]</span><br><span class="line">	order = np.argsort(S)[::-<span class="number">1</span>]</span><br><span class="line">	S = S[order]</span><br><span class="line">	U = U[:,order]</span><br><span class="line">	V = V[order,:]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">		S = S[S/S[<span class="number">0</span>]&gt;<span class="number">1.0e-15</span>]</span><br><span class="line">		Dc = <span class="built_in">min</span>(<span class="built_in">len</span>(S),Dcut)</span><br><span class="line">		S = S[:Dc]</span><br><span class="line">		U = U[:,:Dc]</span><br><span class="line">		V = V[:Dc,:]</span><br><span class="line">		S[S/S[<span class="number">0</span>]&lt;prec] = prec</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">		S = S[S/S[<span class="number">0</span>]&gt;prec]</span><br><span class="line">		Dc = <span class="built_in">min</span>(<span class="built_in">len</span>(S),Dcut)</span><br><span class="line">		S = S[:Dc]</span><br><span class="line">		U = U[:,:Dc]</span><br><span class="line">		V = V[:Dc,:]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> iweight == <span class="number">1</span>:</span><br><span class="line">		U = np.dot(U,np.diag(np.sqrt(S)))</span><br><span class="line">		V = np.dot(np.diag(np.sqrt(S)),V)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> icheck == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">if</span> iweight == <span class="number">0</span>:</span><br><span class="line">			<span class="built_in">print</span>(LA.norm(np.dot(U,np.dot(np.diag(S),V))-A)/LA.norm(A))</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span>(LA.norm(np.dot(U,V)-A)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> U,S,V,Dc</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Mps_QRP</span>(<span class="params">UL,T,icheck=<span class="number">0</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; (0-UL-1)(0-T-L) -&gt; (0-Tnew-L)(0-UR-1) &quot;&quot;&quot;</span></span><br><span class="line">	shapeT = np.asarray(np.shape(T))</span><br><span class="line">	rankT = <span class="built_in">len</span>(shapeT)</span><br><span class="line">	</span><br><span class="line">	A = np.tensordot(UL,T,(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">	A = np.reshape(A,[np.prod(shapeT[:-<span class="number">1</span>]),shapeT[-<span class="number">1</span>]])</span><br><span class="line">	Tnew,UR = linalg.qr(A,mode = <span class="string">&#x27;economic&#x27;</span>)</span><br><span class="line">	Sign = np.diag(np.sign(np.diag(UR)))</span><br><span class="line">	Tnew = np.dot(Tnew,Sign)</span><br><span class="line">	UR = np.dot(Sign,UR)</span><br><span class="line">	Tnew = np.reshape(Tnew,shapeT)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> icheck == <span class="number">1</span>:</span><br><span class="line">		A = np.reshape(A,shapeT)</span><br><span class="line">		B = np.tensordot(Tnew,UR,(rankT-<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">		A = np.tensordot(np.conj(Tnew),Tnew,(<span class="built_in">range</span>(<span class="number">0</span>,rankT-<span class="number">1</span>),<span class="built_in">range</span>(<span class="number">0</span>,rankT-<span class="number">1</span>)))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-np.eye(shapeT[-<span class="number">1</span>])))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Tnew,UR</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Mps_LQP</span>(<span class="params">T,UR,icheck=<span class="number">0</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; (0-T-L)(0-UR-1) -&gt; (0-UL-1)(0-Tnew-L) &quot;&quot;&quot;</span></span><br><span class="line">	shapeT = np.asarray(np.shape(T))</span><br><span class="line">	rankT = <span class="built_in">len</span>(shapeT)</span><br><span class="line">	</span><br><span class="line">	A = np.tensordot(T,UR,(rankT-<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">	A = np.reshape(A,[shapeT[<span class="number">0</span>],np.prod(shapeT[<span class="number">1</span>:])])</span><br><span class="line">	UL,Tnew = linalg.rq(A,mode = <span class="string">&#x27;economic&#x27;</span>)</span><br><span class="line">	Sign = np.diag(np.sign(np.diag(UL)))</span><br><span class="line">	UL = np.dot(UL,Sign)</span><br><span class="line">	Tnew = np.dot(Sign,Tnew)</span><br><span class="line">	Tnew = np.reshape(Tnew,shapeT)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> icheck == <span class="number">1</span>:</span><br><span class="line">		A = np.reshape(A,shapeT)</span><br><span class="line">		B = np.tensordot(UL,Tnew,(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">		A = np.tensordot(np.conj(Tnew),Tnew,(<span class="built_in">range</span>(<span class="number">1</span>,rankT),<span class="built_in">range</span>(<span class="number">1</span>,rankT)))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-np.eye(shapeT[<span class="number">0</span>])))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> UL,Tnew</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Mps_QR0P</span>(<span class="params">T,icheck=<span class="number">0</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; (0-T-L) -&gt; (0-Tnew-L)(0-UR-1) &quot;&quot;&quot;</span></span><br><span class="line">	shapeT = np.asarray(np.shape(T))</span><br><span class="line">	rankT = <span class="built_in">len</span>(shapeT)</span><br><span class="line">	</span><br><span class="line">	A = np.reshape(T,[np.prod(shapeT[:-<span class="number">1</span>]),shapeT[-<span class="number">1</span>]])</span><br><span class="line">	Tnew,UR = linalg.qr(A,mode = <span class="string">&#x27;economic&#x27;</span>)</span><br><span class="line">	Sign = np.diag(np.sign(np.diag(UR)))</span><br><span class="line">	Tnew = np.dot(Tnew,Sign)</span><br><span class="line">	UR = np.dot(Sign,UR)</span><br><span class="line">	Tnew = np.reshape(Tnew,shapeT)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> icheck == <span class="number">1</span>:</span><br><span class="line">		B = np.tensordot(Tnew,UR,(rankT-<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(T-B)/LA.norm(T))</span><br><span class="line">		A = np.tensordot(np.conj(Tnew),Tnew,(<span class="built_in">range</span>(<span class="number">0</span>,rankT-<span class="number">1</span>),<span class="built_in">range</span>(<span class="number">0</span>,rankT-<span class="number">1</span>)))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-np.eye(shapeT[-<span class="number">1</span>])))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Tnew,UR</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Mps_LQ0P</span>(<span class="params">T,icheck=<span class="number">0</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; (0-T-L) -&gt; (0-UL-1)(0-Tnew-L) &quot;&quot;&quot;</span></span><br><span class="line">	shapeT = np.asarray(np.shape(T))</span><br><span class="line">	rankT = <span class="built_in">len</span>(shapeT)</span><br><span class="line">	</span><br><span class="line">	A = np.reshape(T,[shapeT[<span class="number">0</span>],np.prod(shapeT[<span class="number">1</span>:])])</span><br><span class="line">	UL,Tnew = linalg.rq(A,mode = <span class="string">&#x27;economic&#x27;</span>)</span><br><span class="line">	Sign = np.diag(np.sign(np.diag(UL)))</span><br><span class="line">	UL = np.dot(UL,Sign)</span><br><span class="line">	Tnew = np.dot(Sign,Tnew)</span><br><span class="line">	Tnew = np.reshape(Tnew,shapeT)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> icheck == <span class="number">1</span>:</span><br><span class="line">		B = np.tensordot(UL,Tnew,(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(T-B)/LA.norm(T))</span><br><span class="line">		A = np.tensordot(np.conj(Tnew),Tnew,(<span class="built_in">range</span>(<span class="number">1</span>,rankT),<span class="built_in">range</span>(<span class="number">1</span>,rankT)))</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-np.eye(shapeT[<span class="number">0</span>])))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> UL,Tnew</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	Test = &#123;&#125;</span><br><span class="line">	Test[<span class="string">&#x27;Group&#x27;</span>] = <span class="number">0</span></span><br><span class="line">	Test[<span class="string">&#x27;NCon&#x27;</span>] = <span class="number">0</span></span><br><span class="line">	Test[<span class="string">&#x27;SplitEig&#x27;</span>] = <span class="number">0</span></span><br><span class="line">	Test[<span class="string">&#x27;SplitSvd&#x27;</span>] = <span class="number">0</span></span><br><span class="line">	Test[<span class="string">&#x27;Mps_QRP&#x27;</span>] = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> Test[<span class="string">&#x27;Group&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">		A = np.random.rand(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">		A = Group(A,[[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>]])</span><br><span class="line">		<span class="built_in">print</span>(A)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> Test[<span class="string">&#x27;NCon&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">		T1 = np.random.rand(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">		T2 = np.random.rand(<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">		T3 = np.random.rand(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">	</span><br><span class="line">		A = np.tensordot(T1,T2,([<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line">		A = np.transpose(A,[<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line">		B = NCon([T1,T2],[[<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">4</span>,<span class="number">2</span>],[-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">3</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">		A = np.tensordot(T1,T2,(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">		A = np.transpose(A,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>])</span><br><span class="line">		B = NCon([T1,T2],[[-<span class="number">5</span>,-<span class="number">1</span>,-<span class="number">4</span>,<span class="number">1</span>],[-<span class="number">2</span>,-<span class="number">3</span>,<span class="number">1</span>,-<span class="number">6</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">		A = np.tensordot(T1,T2,([<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line">		A = np.tensordot(A,T3,([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]))</span><br><span class="line">		A = np.transpose(A,[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">		B = NCon([T1,T2,T3],[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">3</span>],[-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">1</span>,<span class="number">4</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">		</span><br><span class="line">		T1 = np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">		T2 = np.random.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">		T3 = np.random.rand(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">	</span><br><span class="line">		A = np.kron(T1,T2)</span><br><span class="line">		A = np.reshape(A,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">		B = NCon([T1,T2],[[-<span class="number">1</span>,-<span class="number">3</span>],[-<span class="number">2</span>,-<span class="number">4</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">		A = np.kron(T1,T2)</span><br><span class="line">		A = np.kron(A,T3)</span><br><span class="line">		A = np.reshape(A,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>])</span><br><span class="line">		A = np.transpose(A,[<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">		B = NCon([T1,T2,T3],[[-<span class="number">2</span>,-<span class="number">6</span>],[-<span class="number">1</span>,-<span class="number">4</span>],[-<span class="number">5</span>,-<span class="number">3</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">		</span><br><span class="line">		T = np.random.rand(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">	</span><br><span class="line">		A = np.eye(<span class="number">3</span>)</span><br><span class="line">		A = np.tensordot(T,A,([<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>]))</span><br><span class="line">		A = np.transpose(A,[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">		B = NCon([T],[[<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>,<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">		A = np.eye(<span class="number">3</span>*<span class="number">2</span>)</span><br><span class="line">		A = np.reshape(A,[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">		A = np.tensordot(T,A,([<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">		B = NCon([T],[[<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">		</span><br><span class="line">		T1 = np.random.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">		T2 = np.random.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">		T3 = np.random.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">	</span><br><span class="line">		A = np.tensordot(T1,T2,(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">		A = np.kron(A,T3)</span><br><span class="line">		A = np.reshape(A,[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">		B = NCon([T1,T2,T3],[[-<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,-<span class="number">3</span>],[-<span class="number">2</span>,-<span class="number">4</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">		T1 = np.random.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">		T2 = np.random.rand(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">		T3 = np.random.rand(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">		T4 = np.random.rand(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">	</span><br><span class="line">		A = np.tensordot(T1,T2,(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">		A = np.tensordot(A,T3,(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">		A = np.tensordot(A,T4,([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">		B = NCon([T1,T2,T3,T4],[[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">		<span class="built_in">print</span>(LA.norm(A-B)/LA.norm(A))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Test[<span class="string">&#x27;SplitEig&#x27;</span>] == <span class="number">1</span>) | (Test[<span class="string">&#x27;SplitSvd&#x27;</span>] == <span class="number">1</span>):</span><br><span class="line">		T = np.zeros((<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">		T[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">		T[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">		T[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">		T[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">		T[<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">		T[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line">		T[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">		</span><br><span class="line">		G = np.zeros((<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">		G[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">		G[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">		G[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">		G[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">		A = np.tensordot(T,G,(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">		A = np.tensordot(A,G,(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">		A = np.tensordot(A,G,(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">		A = np.tensordot(A,np.conj(A),([<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br><span class="line">		STA = Group(A,[[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>]])</span><br><span class="line">	</span><br><span class="line">		A = np.reshape(T,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">		A = np.tensordot(A,np.conj(A),(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">		STB = Group(A,[[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>]])</span><br><span class="line">	</span><br><span class="line">		A = np.tensordot(STA,STB,([<span class="number">0</span>],[<span class="number">0</span>]))</span><br><span class="line">		ST0 = np.transpose(A,[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> Test[<span class="string">&#x27;SplitEig&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">		ST = Group(ST0,[[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">		STh = (ST+np.transpose(ST))/<span class="number">2</span></span><br><span class="line">		ST0h = np.reshape(STh,[<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>])</span><br><span class="line">		Dfull = np.shape(ST)[<span class="number">0</span>]</span><br><span class="line">		<span class="built_in">print</span>(Dfull)</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;full eig&#x27;</span>)</span><br><span class="line">		V,S,Dc = SplitEig(STh,Dfull)</span><br><span class="line">		Sfull = S</span><br><span class="line">		<span class="built_in">print</span>(Sfull,<span class="built_in">len</span>(Sfull))</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;partial eig&#x27;</span>)</span><br><span class="line">		<span class="keyword">for</span> Dcut <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,Dfull+<span class="number">1</span>):</span><br><span class="line">			V,S,Dc = SplitEig(STh,Dcut)</span><br><span class="line">			<span class="built_in">print</span>(Dcut,Dc,LA.norm(<span class="built_in">abs</span>(S)-<span class="built_in">abs</span>(Sfull[:Dc])))</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;full eigh&#x27;</span>)</span><br><span class="line">		V,S,Dc = SplitEigh(STh,Dfull,icheck=<span class="number">1</span>)</span><br><span class="line">		Sfull = S</span><br><span class="line">		<span class="built_in">print</span>(Sfull,<span class="built_in">len</span>(Sfull))</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;partial eigh&#x27;</span>)</span><br><span class="line">		<span class="keyword">for</span> Dcut <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,Dfull+<span class="number">1</span>):</span><br><span class="line">			V,S,Dc = SplitEigh(STh,Dcut,icheck=<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">print</span>(Dcut,Dc,LA.norm(<span class="built_in">abs</span>(S)-<span class="built_in">abs</span>(Sfull[:Dc])))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> Test[<span class="string">&#x27;SplitSvd&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">		ST = Group(ST0,[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">		ST1 = Group(ST0,[[<span class="number">0</span>],[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">		ST2 = Group(ST0,[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])</span><br><span class="line">		Dfull = np.shape(ST)[<span class="number">0</span>]</span><br><span class="line">		<span class="built_in">print</span>(Dfull)</span><br><span class="line"></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;full svd&#x27;</span>)</span><br><span class="line">		<span class="keyword">for</span> iweight <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">			U,S,V,Dc = SplitSvd_Lapack(ST,Dfull,iweight,icheck=<span class="number">1</span>)</span><br><span class="line">		Sfull = S</span><br><span class="line">		<span class="built_in">print</span>(Sfull,<span class="built_in">len</span>(Sfull))</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;partial svd&#x27;</span>)</span><br><span class="line">		<span class="keyword">for</span> Dcut <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,Dfull+<span class="number">1</span>):</span><br><span class="line">			<span class="keyword">for</span> iweight <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">				U,S,V,Dc = SplitSvd_Lapack(ST,Dcut,iweight,mode=<span class="string">&#x27;C&#x27;</span>,icheck=<span class="number">1</span>)</span><br><span class="line">				<span class="built_in">print</span>(Dcut,iweight,Dc,LA.norm(S-Sfull[:Dc]))</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> Test[<span class="string">&#x27;Mps_QRP&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;no Z2, rank 3&#x27;</span>)</span><br><span class="line">		<span class="keyword">for</span> D1,D2,D3 <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">5</span>)):</span><br><span class="line">			D = [D1,D2,D3]</span><br><span class="line">			T0 = np.random.rand(D[<span class="number">0</span>],D[<span class="number">1</span>],D[<span class="number">2</span>]) + <span class="number">1j</span>*np.random.rand(D[<span class="number">0</span>],D[<span class="number">1</span>],D[<span class="number">2</span>])</span><br><span class="line">			UL = np.random.rand(D[<span class="number">0</span>],D[<span class="number">0</span>]) + <span class="number">1j</span>*np.random.rand(D[<span class="number">0</span>],D[<span class="number">0</span>])</span><br><span class="line">			UR = np.random.rand(D[<span class="number">2</span>],D[<span class="number">2</span>]) + <span class="number">1j</span>*np.random.rand(D[<span class="number">2</span>],D[<span class="number">2</span>])</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">print</span>(D1,D2,D3)</span><br><span class="line">			T,UR = Mps_QRP(UL,T0,icheck=<span class="number">1</span>)</span><br><span class="line">			UL,T = Mps_LQP(T0,UR,icheck=<span class="number">1</span>)</span><br><span class="line">			T,UR = Mps_QR0P(T0,icheck=<span class="number">1</span>)</span><br><span class="line">			UL,T = Mps_LQ0P(T0,icheck=<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;no Z2, rank 4&#x27;</span>)</span><br><span class="line">		<span class="keyword">for</span> D1,D2,D3,D4 <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">5</span>)):</span><br><span class="line">			D = [D1,D2,D3,D4]</span><br><span class="line">			T0 = np.random.rand(D[<span class="number">0</span>],D[<span class="number">1</span>],D[<span class="number">2</span>],D[<span class="number">3</span>]) + <span class="number">1j</span>*np.random.rand(D[<span class="number">0</span>],D[<span class="number">1</span>],D[<span class="number">2</span>],D[<span class="number">3</span>])</span><br><span class="line">			UL = np.random.rand(D[<span class="number">0</span>],D[<span class="number">0</span>]) + <span class="number">1j</span>*np.random.rand(D[<span class="number">0</span>],D[<span class="number">0</span>])</span><br><span class="line">			UR = np.random.rand(D[<span class="number">3</span>],D[<span class="number">3</span>]) + <span class="number">1j</span>*np.random.rand(D[<span class="number">3</span>],D[<span class="number">3</span>])</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">print</span>(D1,D2,D3,D4)</span><br><span class="line">			T,UR = Mps_QRP(UL,T0,icheck=<span class="number">1</span>)</span><br><span class="line">			UL,T = Mps_LQP(T0,UR,icheck=<span class="number">1</span>)</span><br><span class="line">			T,UR = Mps_QR0P(T0,icheck=<span class="number">1</span>)</span><br><span class="line">			UL,T = Mps_LQ0P(T0,icheck=<span class="number">1</span>)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Semiconductor Physics(section 2)</title>
    <url>/2022/11/12/Semiconductor%20physics2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="A-The-density-of-states"><a href="#A-The-density-of-states" class="headerlink" title="A. The density of states"></a>A. The density of states</h3>]]></content>
      <categories>
        <category>Semiconductor Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/2022/09/08/221107sub/index/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个总是在追求失去的东西的人</p>
]]></content>
  </entry>
  <entry>
    <title>3-site iTEBD method</title>
    <url>/2022/11/22/HW_itebd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size = 5> Homework</font>

<ul>
<li>consider the 1D spin model with open boundary condition</li>
</ul>
<script type="math/tex; mode=display">
H=-\sum_j\left(\sigma_{j-1}^z \sigma_j^y \sigma_{j+1}^z+\sigma_j^x\right)</script><ul>
<li><p>write a code for the 3-site iTEBD method</p>
<p>  choose $D_{s} =  6 $, calculate the ground state energy $E$ per site, and the magnetization per site $\left\langle\sigma_i^z\right\rangle$ and $\left\langle\sigma_i^x\right\rangle$</p>
<p>  show the data of entanglement entropy and entanglement spectrum</p>
</li>
</ul>
<font size=3.5> A brief summary of theory and algorithm </font>

<ul>
<li><p>对于 3-site 的 iTEBD，有三种 T 和 G，如下图所示；不同颜色的方框表示不同的TG的演化合并的过程，如此迭代</p>
  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/22/9hA6bVFf14rXKks.png style="zoom:50%" />   
  </div>
</li>
<li><p>update 的过程包含两次 SVD 分解，第二次注意要把 Gm1 作为环境乘进去：</p>
  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/22/CO4zIKdUijMYmEP.png style="zoom:60%" />   
  </div>
</li>
<li><p>代码如下：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">3-site iTEBD method</span></span><br><span class="line"><span class="string">1D spin model with OBC</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> LA</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> LAs</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> Sub180221 <span class="keyword">as</span> Sub</span><br><span class="line"><span class="keyword">import</span> math,copy,pickle</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetHam_3sitespin</span>(<span class="params">Dp</span>):													<span class="comment">#生成哈密顿量</span></span><br><span class="line">	S0,Sp,Sm,Sz,Sx,Sy = Sub.SpinOper(Dp)</span><br><span class="line">	sz = <span class="number">2</span>* Sz</span><br><span class="line">	sx = <span class="number">2</span>* Sx</span><br><span class="line">	sy = <span class="number">2</span>* Sy</span><br><span class="line">	Ham = - (np.kron(np.kron(sz,sy),sz)) - (np.kron(np.kron(S0,sx),S0))</span><br><span class="line">	Ham = np.reshape(Ham,[Dp,Dp,Dp,Dp,Dp,Dp])</span><br><span class="line">	<span class="keyword">return</span> Ham</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetExpHam</span>(<span class="params">Ham,Tau</span>):														<span class="comment">#乘演化的 exp</span></span><br><span class="line">	Dp = np.shape(Ham)[<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> LA.norm(Ham) &lt; <span class="number">1.0e-12</span>:</span><br><span class="line">		UH = np.reshape(np.eye(Dp**<span class="number">3</span>),[Dp,Dp,Dp,Dp,Dp,Dp])</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		A = np.reshape(Ham,[Dp**<span class="number">3</span>,Dp**<span class="number">3</span>])</span><br><span class="line">		V,S,Dc = Sub.SplitEigh(A,Dp**<span class="number">3</span>)</span><br><span class="line">		</span><br><span class="line">		W = np.diag(np.exp(-Tau*S))</span><br><span class="line">		A = np.dot(np.dot(V,W),np.transpose(np.conj(V)))</span><br><span class="line">		UH = np.reshape(A,[Dp,Dp,Dp,Dp,Dp,Dp])</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> UH</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">InitTG</span>(<span class="params">Dp,Ds,kind</span>):														</span><br><span class="line">	T = [<span class="literal">None</span>]*<span class="number">3</span></span><br><span class="line">	G = [<span class="literal">None</span>]*<span class="number">3</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> kind == <span class="string">&#x27;rand&#x27;</span>:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">			T[i] = np.random.rand(Ds,Dp,Ds)</span><br><span class="line">			G[i] = np.random.rand(Ds)</span><br><span class="line">	<span class="keyword">return</span> T,G</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ImportTG</span>(<span class="params">Ds,Label</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		File_TG = <span class="built_in">open</span>(<span class="string">&#x27;Tebd&#x27;</span>+Label+<span class="string">&#x27;.pklz&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">		TG = pickle.load(File_TG)</span><br><span class="line">		File_TG.close()</span><br><span class="line">		(T,G) = (TG[<span class="string">&#x27;T&#x27;</span>],TG[<span class="string">&#x27;G&#x27;</span>])</span><br><span class="line">	<span class="keyword">except</span> IOError:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Missing&#x27;</span>) </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> T,G</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ExportTG</span>(<span class="params">Ds,T,G,Label</span>):</span><br><span class="line">	TG = &#123;<span class="string">&#x27;T&#x27;</span>:T,<span class="string">&#x27;G&#x27;</span>:G&#125;</span><br><span class="line">	File_TG = <span class="built_in">open</span>(<span class="string">&#x27;Tebd&#x27;</span>+Label+<span class="string">&#x27;.pklz&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">	pickle.dump(TG,File_TG)</span><br><span class="line">	File_TG.close()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mySVD</span>(<span class="params">A,Dcut</span>):</span><br><span class="line">	U,S,V = LA.svd(A)</span><br><span class="line">	U = U[:,:Dcut]</span><br><span class="line">	S = S[:Dcut]</span><br><span class="line">	V = V[:Dcut,:]</span><br><span class="line">	<span class="keyword">return</span> U,S,V</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Evo_Bond</span>(<span class="params">Tl,Tm,Tr,Gll,Gl,Gr,Grr,Ds,UH</span>):									<span class="comment">#update 过程，做两次 SVD</span></span><br><span class="line">	A = Sub.NCon([np.diag(Gll),Tl,np.diag(Gl),Tm,np.diag(Gr),Tr,np.diag(Grr),UH],[[-<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>],[<span class="number">6</span>,-<span class="number">5</span>],[-<span class="number">2</span>,-<span class="number">3</span>,-<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">	DA = np.shape(A)</span><br><span class="line">	A = Sub.Group(A,[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])										<span class="comment">#重整成一个矩阵</span></span><br><span class="line"></span><br><span class="line">	U1,Gm1,V1,Dc1 = Sub.SplitSvd_Lapack(A,Ds,<span class="number">0</span>,prec=<span class="number">1.0e-12</span>)</span><br><span class="line">	Gm1 /= np.sqrt(np.<span class="built_in">sum</span>(Gm1**<span class="number">2</span>))</span><br><span class="line">	U1 = np.reshape(U1,[DA[<span class="number">0</span>],DA[<span class="number">1</span>],Dc1])</span><br><span class="line">	Tl = np.tensordot(np.diag(<span class="number">1.0</span>/Gll),U1,(<span class="number">1</span>,<span class="number">0</span>))							<span class="comment">#将 Gll 还原出去</span></span><br><span class="line">	V1 = np.tensordot(np.diag(Gm1),V1,(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">	V1 = np.reshape(V1,[<span class="number">12</span>,<span class="number">12</span>])												<span class="comment">#重整成一个矩阵		</span></span><br><span class="line"></span><br><span class="line">	U2,Gm2,V2,Dc2 = Sub.SplitSvd_Lapack(V1,Ds,<span class="number">0</span>,prec=<span class="number">1.0e-12</span>)</span><br><span class="line">	Gm2 /= np.sqrt(np.<span class="built_in">sum</span>(Gm2**<span class="number">2</span>))	</span><br><span class="line">	V2 = np.reshape(V2,[Dc2,DA[<span class="number">3</span>],DA[<span class="number">4</span>]])</span><br><span class="line">	Tr = np.tensordot(V2,np.diag(<span class="number">1.0</span>/Grr),(<span class="number">2</span>,<span class="number">0</span>))							<span class="comment">#将 Grr 还原出去</span></span><br><span class="line">	Tm = np.reshape(U2,[DA[<span class="number">0</span>],DA[<span class="number">1</span>],Dc1])</span><br><span class="line">	Tm = np.tensordot(np.diag(<span class="number">1.0</span>/Gm1),Tm,(<span class="number">1</span>,<span class="number">0</span>))							<span class="comment">#将 Gl 还原出去</span></span><br><span class="line">	<span class="keyword">return</span> Tl,Tm,Tr,Gm1,Gm2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Evo</span>(<span class="params">Ds,Ham,Tau,Iter,Prec,Label</span>):										<span class="comment">#主循环</span></span><br><span class="line">	Dp = np.shape(Ham)[<span class="number">0</span>]</span><br><span class="line">	T,G = InitTG(Dp,Ds,<span class="string">&#x27;rand&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	File_Log = <span class="built_in">open</span>(<span class="string">&#x27;Log&#x27;</span>+Label+<span class="string">&#x27;.dat&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	r0 = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> idt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Tau)):</span><br><span class="line">		dt = Tau[idt]</span><br><span class="line">		UH = GetExpHam(Ham,dt)</span><br><span class="line">		</span><br><span class="line">		G0 = np.ones(<span class="number">3</span>)</span><br><span class="line">		<span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(Iter):</span><br><span class="line">			<span class="keyword">for</span> ib <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">				T[ib],T[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)],T[np.mod(ib+<span class="number">2</span>,<span class="number">3</span>)],G[ib],G[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)] =\</span><br><span class="line">				Evo_Bond(T[ib],T[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)],T[np.mod(ib+<span class="number">2</span>,<span class="number">3</span>)],G[np.mod(ib-<span class="number">1</span>,<span class="number">3</span>)],G[ib],G[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)],G[np.mod(ib+<span class="number">2</span>,<span class="number">3</span>)],Ds,UH)</span><br><span class="line">			Err = <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">				Err += <span class="built_in">abs</span>(G[i][<span class="number">0</span>]-G0[i])</span><br><span class="line">			<span class="keyword">if</span> np.mod(r,<span class="number">100</span>) == <span class="number">1</span>:</span><br><span class="line">				<span class="comment">#print(r+r0,Err)</span></span><br><span class="line">				File_Log.write(<span class="string">&#x27;%d \t %0.15f \n&#x27;</span> % <span class="built_in">tuple</span>((r+r0,Err)))</span><br><span class="line">				File_Log.flush()</span><br><span class="line">			<span class="keyword">if</span> Err &lt; Prec[idt]:</span><br><span class="line">				r0 += r</span><br><span class="line">				<span class="built_in">print</span>(dt,r+r0,Err)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">				G0[i] = G[i][<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">	File_Log.close()</span><br><span class="line">	ExportTG(Ds,T,G,Label)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Cal_Bond</span>(<span class="params">Op,Tl,Tm,Tr,Gll,Gl,Gr,Grr</span>):									<span class="comment">#计算 &lt;psi|OP|psi&gt;				</span></span><br><span class="line">	A = Sub.NCon([np.diag(Gll),Tl,np.diag(Gl),Tm,np.diag(Gr),Tr,np.diag(Grr)],[[-<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,-<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,-<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,-<span class="number">4</span>,<span class="number">6</span>],[<span class="number">6</span>,-<span class="number">5</span>]])</span><br><span class="line">	Val = Sub.NCon([A,Op,np.conj(A)],[[<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>]])</span><br><span class="line">	<span class="keyword">return</span> np.real(Val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Cal_Site</span>(<span class="params">Op,T,Gl,Gr</span>):													<span class="comment"># 计算单个 site 的 &lt;site|OP|site&gt;</span></span><br><span class="line">	A = Sub.NCon([np.diag(Gl),T,np.diag(Gr)],[[-<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,-<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,-<span class="number">3</span>]])</span><br><span class="line">	Val = Sub.NCon([A,Op,np.conj(A)],[[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]])</span><br><span class="line">	<span class="keyword">return</span> np.real(Val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Cal</span>(<span class="params">Ds,Ham,Label</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;***************************************************************************************&quot;</span>)</span><br><span class="line">	T,G = ImportTG(Ds,Label)</span><br><span class="line">	</span><br><span class="line">	D = np.shape(Ham)[<span class="number">0</span>]</span><br><span class="line">	H00 = np.reshape(np.eye(D**<span class="number">3</span>,D**<span class="number">3</span>),[D,D,D,D,D,D])</span><br><span class="line">	S0,Sp,Sm,Sz,Sx,Sy = Sub.SpinOper(D)</span><br><span class="line">	sz = <span class="number">2</span>* Sz</span><br><span class="line">	sx = <span class="number">2</span>* Sx</span><br><span class="line"></span><br><span class="line">	Nom = np.zeros(<span class="number">3</span>)</span><br><span class="line">	Eng = np.zeros(<span class="number">3</span>)</span><br><span class="line">	Mz = np.zeros(<span class="number">3</span>)</span><br><span class="line">	Mx = np.zeros(<span class="number">3</span>)</span><br><span class="line">	EE = []</span><br><span class="line">	ES = []</span><br><span class="line">	avgES = []</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;ib &quot;</span>+<span class="string">&quot; Nom &quot;</span>+<span class="string">&quot; Eng &quot;</span>+<span class="string">&quot; Mag z &quot;</span>+<span class="string">&quot; Mag x &quot;</span>+<span class="string">&quot; entanglement entropy &quot;</span>+<span class="string">&quot; entanglement spectrum &quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> ib <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">		Nom[ib] = Cal_Bond(H00,T[ib],T[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)],T[np.mod(ib+<span class="number">2</span>,<span class="number">3</span>)],G[np.mod(ib-<span class="number">1</span>,<span class="number">3</span>)],G[ib],G[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)],G[np.mod(ib+<span class="number">2</span>,<span class="number">3</span>)])</span><br><span class="line">		Eng[ib] = Cal_Bond(Ham,T[ib],T[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)],T[np.mod(ib+<span class="number">2</span>,<span class="number">3</span>)],G[np.mod(ib-<span class="number">1</span>,<span class="number">3</span>)],G[ib],G[np.mod(ib+<span class="number">1</span>,<span class="number">3</span>)],G[np.mod(ib+<span class="number">2</span>,<span class="number">3</span>)])</span><br><span class="line">		Mz[ib] = Cal_Site(sz,T[ib],G[np.mod(ib-<span class="number">1</span>,<span class="number">3</span>)],G[ib])</span><br><span class="line">		Mx[ib] = Cal_Site(sx,T[ib],G[np.mod(ib-<span class="number">1</span>,<span class="number">3</span>)],G[ib])</span><br><span class="line">		Eng[ib] /= Nom[ib]</span><br><span class="line">		Mz[ib] /= Nom[ib]</span><br><span class="line">		Mx[ib] /= Nom[ib]</span><br><span class="line"></span><br><span class="line">		ES.append(G[ib])</span><br><span class="line">		ln_EV = np.matrix(np.log2(ES[ib]))</span><br><span class="line">		EV = np.matrix(ES[ib])</span><br><span class="line">		EE.append(-np.dot(EV, ln_EV.H))</span><br><span class="line"></span><br><span class="line">		<span class="built_in">print</span>(ib,np.around(Nom[ib],<span class="number">6</span>),np.around(Eng[ib],<span class="number">6</span>),np.around(Mz[ib],<span class="number">7</span>),np.around(Mx[ib],<span class="number">7</span>),EE[ib],ES[ib])</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;***************************************************************************************&quot;</span>)</span><br><span class="line"></span><br><span class="line">	Eng = np.mean(Eng)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;ground E per site:&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(Eng)</span><br><span class="line">	</span><br><span class="line">	Mz = np.mean(Mz)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;magnetization z per site:&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(Mz)</span><br><span class="line">	Mx = np.mean(Mx)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;magnetization x per site:&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(Mx)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;entanglement entropy and entanglement spectrum:&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(np.mean(EE))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">		avgES.append((ES[<span class="number">0</span>][i]+ES[<span class="number">1</span>][i]+ES[<span class="number">2</span>][i])/<span class="number">3</span>)</span><br><span class="line">	<span class="built_in">print</span>(avgES)</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Plot</span>(<span class="params">Ds</span>):</span><br><span class="line">	Label = <span class="string">&#x27;-D&#x27;</span>+<span class="built_in">str</span>(Ds)</span><br><span class="line">	Err = np.loadtxt(<span class="string">&#x27;Log&#x27;</span>+Label+<span class="string">&#x27;.dat&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	fig = pl.figure()</span><br><span class="line">	pl.plot(Err[:,<span class="number">0</span>],np.log(np.<span class="built_in">abs</span>(Err[:,<span class="number">1</span>]))/np.log(<span class="number">10</span>))</span><br><span class="line">	pl.xlabel(<span class="string">&#x27;Iteration&#x27;</span>)</span><br><span class="line">	pl.ylabel(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">	fig.savefig(<span class="string">&#x27;Err&#x27;</span>+Label+<span class="string">&#x27;.pdf&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	Ds = <span class="number">6</span></span><br><span class="line">	Dp = <span class="number">2</span></span><br><span class="line">	</span><br><span class="line">	Tau = [<span class="number">0.1</span>,<span class="number">0.01</span>,<span class="number">0.001</span>]</span><br><span class="line">	Iter = <span class="number">100000</span></span><br><span class="line">	Prec = [<span class="number">1.0e-10</span>]*<span class="number">3</span></span><br><span class="line">	Label = <span class="string">&#x27;-D&#x27;</span>+<span class="built_in">str</span>(Ds)</span><br><span class="line">	</span><br><span class="line">	Ham = GetHam_3sitespin(Dp)</span><br><span class="line">	Evo(Ds,Ham,Tau,Iter,Prec,Label)</span><br><span class="line">	Plot(Ds)</span><br><span class="line">	Cal(Ds,Ham,Label)</span><br></pre></td></tr></table></figure>
<pre><code>0.1 5894 9.963463387663296e-11
0.01 29097 9.996781180632297e-11
0.001 102908 9.999789885029031e-11
***************************************************************************************
ib  Nom  Eng  Mag z  Mag x  entanglement entropy  entanglement spectrum 
0 1.0 -1.196414 -0.1612558 0.6107703 [[1.68910627]] [0.88586489 0.42204271 0.16637421 0.08864772 0.03659217 0.0156705 ]
1 1.0 -1.197 -0.1616391 0.6101772 [[1.68961957]] [0.88582456 0.42207902 0.16644626 0.08872146 0.03663422 0.01569149]
2 1.0 -1.197545 0.1614238 0.6104471 [[1.6896294]] [0.88582307 0.42208483 0.16643798 0.0887227  0.0366377  0.01569247]
***************************************************************************************
ground E per site:
-1.196986423260931
magnetization z per site:
-0.05382368800930137
magnetization x per site:
0.6104648847112727
entanglement entropy and entanglement spectrum:
1.6894517483722928
[0.8858375061701803, 0.42206885253163623, 0.1664194864064454, 0.08869729347868575, 0.03662135992053934, 0.01568481868848111]
</code></pre><div  align="center">    
<img src=https://s2.loli.net/2022/11/22/gIfsPoDp6CQYAmw.png style="zoom:50%" />   
</div>

<p>​    </p>
<ul>
<li><p>小结：</p>
<ul>
<li><p>基态能量约为 -1.197， 和上次的 ED / MPS 结果基本相符合（考虑到iTEBD是N无限大的OBC）。</p>
</li>
<li><p>sigmaz 磁化强度约为 0 ，sigmax 磁化强度约为 0.61</p>
</li>
<li><p>纠缠熵(log2)约为 1.689，纠缠谱数据如下：</p>
<p>  [0.8858375061701803, 0.42206885253163623, 0.1664194864064454, 0.08869729347868575, 0.03662135992053934, 0.01568481868848111]</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>Monte Carlo in 2D Ising Model</title>
    <url>/2022/11/22/mc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><font size = 5> Homework </font>

<ul>
<li>consider the 2D classical Ising model on a L×L square lattice with periodic boundary conditions in both directions</li>
</ul>
<script type="math/tex; mode=display">\mathscr{H}=-J \sum_{\langle i, j\rangle} \sigma_i \sigma_j+H \sum_i \sigma_i</script><ul>
<li><p>write a code for the Metropolis algorithm</p>
</li>
<li><p>plot the average energy, average magnetization, specific heat, and magnetic susceptibility as functions of temperature T</p>
</li>
<li><p>explore the scaling behavior near the critical point $T_c=\frac{2 \mathrm{~J}}{\ln (1+\sqrt{2})} \simeq 2.269 \mathrm{~J}$, compare with exact results</p>
</li>
<li><font size = 4.5> A brief summary of theory and algorithm </font>
</li>
<li><p>Monte Carlo simulation</p>
<p>  (1) initialization: choose an initial configuration for the spins</p>
<p>  (2) trial move: we propose a move by randomly choosing a spin and flip it</p>
<p>  (3) acceptation: for a flip 𝜎 old to 𝜎 trival , evaluate the number $\Delta E=2 \sigma_j\left(J \sum \sigma_{\text {near }}-H\right)$, then we generate a uniform random number r ∈ (0,1), if r &lt; 𝛼, accept the move, 𝜎 new = 𝜎 old</p>
<p>  (4) iteration: then we use 𝜎 new as the new starting point and go back to (2)</p>
<p>  we proceed with the process for at least 10^5 - 10^6 Monte Carlo steps</p>
</li>
<li><p>2D Ising Model:</p>
<p>  系统哈密顿量：$\mathscr{H}=-J \sum_{\langle i, j\rangle} \sigma_i \sigma_j+H \sum_i \sigma_i$</p>
<p>  通常忽略外场作用，$H = 0$, 系统能量 $<E> =-J \sum_{N} \sum_{\langle i, j\rangle} \sigma_i \sigma_j$</p>
<p>  平均能量：$<e> = <E> / N$</p>
<p>  磁化强度： $<M> = \sum_{i} s_{i}$</p>
<p>  热容： $C=\frac{1}{N T^2}\left(\left\langle E^2\right\rangle-\langle E\rangle^2\right)$</p>
<p>  磁化率 ：$\chi=\frac{1}{N T}\left(\left\langle M^2\right\rangle-\langle M\rangle^2\right)=\frac{N}{T}\left(\left\langle m^2\right\rangle-\langle m\rangle^2\right)$</p>
</li>
</ul>
<ul>
<li><p>关于计算参数：</p>
<ul>
<li><p>热化步数 Relaxation = 500， 迭代步数 Iteration = 200000（在本地跑大约13分钟）</p>
</li>
<li><p>温度范围：1 ~ 3.5 K，取点间隔为 0.05 K</p>
</li>
<li><p>大小分别取 L = 10,20,30， 周期性边界条件</p>
</li>
<li><p>de_corr = 3 是为了减少数据关联性，两次测量之间的等待步数</p>
<p>代码如下：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">Tstart = <span class="number">0.85</span>                                           <span class="comment">#起始温度</span></span><br><span class="line">Tend = <span class="number">3.5</span>                                              <span class="comment">#终点温度</span></span><br><span class="line">Tstep = <span class="number">0.05</span>                                            <span class="comment">#步长</span></span><br><span class="line"></span><br><span class="line">J = <span class="number">1</span>                                                   <span class="comment">#Ising model 参数</span></span><br><span class="line">H = <span class="number">0</span></span><br><span class="line">Tc = <span class="number">2</span>*J / np.log(<span class="number">1</span>+np.sqrt(<span class="number">2</span>))                         <span class="comment"># Tc = 2.269J    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_state</span>(<span class="params">L</span>):                                    <span class="comment">#返回一个 L*L 的随机spin构型</span></span><br><span class="line">    M = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, (L, L)) * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_choose</span>(<span class="params">L</span>):                                   <span class="comment">#在 L*L Lattice 中随机选一个点</span></span><br><span class="line">    x = np.random.randint(L)</span><br><span class="line">    y = np.random.randint(L)</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nn</span>(<span class="params">x,y,L</span>):                                          <span class="comment"># 返回 (x,y) 最近邻的四个点</span></span><br><span class="line">    <span class="keyword">return</span> (((x-<span class="number">1</span>)%L,y) , (x,(y+<span class="number">1</span>)%L) , ((x+<span class="number">1</span>)%L,y) , (x,(y-<span class="number">1</span>)%L))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_point_E</span>(<span class="params">x,y,<span class="built_in">map</span>,s,N</span>):                        <span class="comment"># 返回 (x,y) 点 s 自旋构型的最近邻能量</span></span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (xx,yy) <span class="keyword">in</span> nn(x,y,N):</span><br><span class="line">        tmp += <span class="built_in">map</span>[xx][yy]</span><br><span class="line">    <span class="keyword">return</span> s * (-J * tmp + H)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_total_E</span>(<span class="params"><span class="built_in">map</span>,N</span>):                                 <span class="comment"># 返回 map 自旋构型的总能量</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="built_in">sum</span> += single_point_E(i,j,<span class="built_in">map</span>,<span class="built_in">map</span>[i][j],N)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MC</span>(<span class="params">T,L,MainLoops,RelaxLoops,step,spin</span>):             <span class="comment"># Monte Carlo 主循环</span></span><br><span class="line">    S = L * L</span><br><span class="line">    Q_M = []</span><br><span class="line">    Q_M2 = []</span><br><span class="line">    Q_E = []</span><br><span class="line">    Q_E2 = []</span><br><span class="line">    Etotal = cal_total_E(spin,L)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(MainLoops+RelaxLoops):               <span class="comment">#循环包括 Relax 和 Sweep</span></span><br><span class="line"></span><br><span class="line">        x,y = random_choose(L)</span><br><span class="line">        s = spin[x][y]</span><br><span class="line">        curE = single_point_E(x,y,spin,s,L)</span><br><span class="line">        newE = single_point_E(x,y,spin,-s,L)</span><br><span class="line">        deltaE = newE - curE</span><br><span class="line">        alpha = np.exp(- deltaE / T)                    <span class="comment">#计算 alpha</span></span><br><span class="line">        <span class="keyword">if</span> deltaE &lt;= <span class="number">0</span>:                                 <span class="comment"># Metropolis 算法</span></span><br><span class="line">            spin[x][y] = -spin[x][y]</span><br><span class="line">            Etotal = Etotal + deltaE</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> np.random.random() &lt; alpha:</span><br><span class="line">                spin[x][y] = -spin[x][y]</span><br><span class="line">                Etotal = Etotal + deltaE</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &gt; RelaxLoops <span class="keyword">and</span> (i-RelaxLoops)%step == <span class="number">0</span>):       <span class="comment">#如果是 sweep 部分，且减少数据关联性</span></span><br><span class="line">        <span class="comment">#if (i &gt; RelaxLoops):</span></span><br><span class="line">            M = np.<span class="built_in">abs</span>(np.<span class="built_in">sum</span>(spin))</span><br><span class="line">            m = M / S</span><br><span class="line">            m2 = m * m</span><br><span class="line">            Q_M.append(m)</span><br><span class="line">            Q_M2.append(m2)</span><br><span class="line"></span><br><span class="line">            e = Etotal / S</span><br><span class="line">            e2 = e * e</span><br><span class="line">            Q_E.append(e)</span><br><span class="line">            Q_E2.append(e2)</span><br><span class="line"></span><br><span class="line">    M_avg = np.mean(Q_M)</span><br><span class="line">    E_avg = np.mean(Q_E)</span><br><span class="line">    C = (np.mean(Q_E2) - np.mean(Q_E) ** <span class="number">2</span>) / (T ** <span class="number">2</span>)</span><br><span class="line">    X = (np.mean(Q_M2) - np.mean(Q_M) ** <span class="number">2</span>) / T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> spin,E_avg,M_avg,C * S,X * S                         <span class="comment">#返回 自选构型，平均能，平均磁化强度，热容，磁化率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_results</span>(<span class="params">A</span>):                                            <span class="comment"># 画四个物理量的图</span></span><br><span class="line">    plt.figure(figsize = (<span class="number">16</span>,<span class="number">10</span>))</span><br><span class="line">    p1 = plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;T&#x27;</span>)  </span><br><span class="line">    plt.ylabel(<span class="string">&#x27;&lt;E&gt;&#x27;</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">0</span>][<span class="number">0</span>],A[<span class="number">0</span>][<span class="number">1</span>], color = <span class="string">&quot;r&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=10&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">1</span>][<span class="number">0</span>],A[<span class="number">1</span>][<span class="number">1</span>], color = <span class="string">&quot;b&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=20&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">2</span>][<span class="number">0</span>],A[<span class="number">2</span>][<span class="number">1</span>], color = <span class="string">&quot;g&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=30&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    p1 = plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;&lt;M&gt;&#x27;</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">0</span>][<span class="number">0</span>],A[<span class="number">0</span>][<span class="number">2</span>], color = <span class="string">&quot;r&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=10&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">1</span>][<span class="number">0</span>],A[<span class="number">1</span>][<span class="number">2</span>], color = <span class="string">&quot;b&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=20&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">2</span>][<span class="number">0</span>],A[<span class="number">2</span>][<span class="number">2</span>], color = <span class="string">&quot;g&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=30&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    p1 = plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">0</span>][<span class="number">0</span>],A[<span class="number">0</span>][<span class="number">3</span>], color = <span class="string">&quot;r&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=10&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">1</span>][<span class="number">0</span>],A[<span class="number">1</span>][<span class="number">3</span>], color = <span class="string">&quot;b&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=20&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">2</span>][<span class="number">0</span>],A[<span class="number">2</span>][<span class="number">3</span>], color = <span class="string">&quot;g&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=30&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    p1 = plt.subplot(<span class="number">224</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">0</span>][<span class="number">0</span>],A[<span class="number">0</span>][<span class="number">4</span>], color = <span class="string">&quot;r&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=10&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">1</span>][<span class="number">0</span>],A[<span class="number">1</span>][<span class="number">4</span>], color = <span class="string">&quot;b&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=20&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    p1.scatter(A[<span class="number">2</span>][<span class="number">0</span>],A[<span class="number">2</span>][<span class="number">4</span>], color = <span class="string">&quot;g&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=30&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">List</span> = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">    Iteration = <span class="number">200000</span></span><br><span class="line">    <span class="comment">#Iteration = 600000</span></span><br><span class="line">    Relaxation = <span class="number">500</span></span><br><span class="line">    de_corr = <span class="number">3</span></span><br><span class="line">    Ans = []</span><br><span class="line">    <span class="keyword">for</span> L <span class="keyword">in</span> <span class="type">List</span>:</span><br><span class="line">        TList = []</span><br><span class="line">        MList = []</span><br><span class="line">        EList = []</span><br><span class="line">        CList = []</span><br><span class="line">        XList = []</span><br><span class="line">        spin = random_state(L)</span><br><span class="line">        <span class="keyword">for</span> T <span class="keyword">in</span> np.arange(Tstart,Tend,Tstep):</span><br><span class="line">            TList.append(T)</span><br><span class="line">            spin,E,M,C,X = MC(T,L,Iteration,Relaxation,de_corr,spin)</span><br><span class="line">            EList.append(E)</span><br><span class="line">            MList.append(M)</span><br><span class="line">            CList.append(C)</span><br><span class="line">            XList.append(X)</span><br><span class="line">        Ans.append((TList[<span class="number">3</span>:],EList[<span class="number">3</span>:],MList[<span class="number">3</span>:],CList[<span class="number">3</span>:],XList[<span class="number">3</span>:]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;compelete : &quot;</span>+<span class="built_in">str</span>(<span class="built_in">round</span>(L/<span class="number">10</span>))+<span class="string">&quot;/3&quot;</span>)</span><br><span class="line">    draw_results(Ans)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>compelete : 1/3
compelete : 2/3
compelete : 3/3
</code></pre><ul>
<li><p>关于临界指数：考虑 $M\sim|T-T_c|^{\beta}$ 和 $\chi \sim |T-T_c|^{-\gamma}$, 我们知道 Excat solution 是 </p>
  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/22/DcelYIoZ4BvPQw8.png style="zoom:70%" />   
  </div>


</li>
</ul>
<pre><code>取对数坐标，分别绘图如下：
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_exponent_M</span>(<span class="params">A,<span class="type">List</span></span>):                                      <span class="comment"># 画临界指数 : M~|T-Tc|^beta</span></span><br><span class="line">    </span><br><span class="line">    plt.figure(figsize = (<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;|T-Tc|*L&#x27;</span>)  </span><br><span class="line">    plt.ylabel(<span class="string">&#x27;&lt;M&gt;*L^1/8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    X = []</span><br><span class="line">    Y = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> A[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">        X.append(np.<span class="built_in">abs</span>(T-Tc) * L)</span><br><span class="line">    <span class="keyword">for</span> M <span class="keyword">in</span> A[<span class="number">0</span>][<span class="number">2</span>]:</span><br><span class="line">        Y.append(M * np.power(L,<span class="number">1</span>/<span class="number">8</span>))</span><br><span class="line">    plt.loglog(X,Y, <span class="string">&#x27;.&#x27;</span>, color = <span class="string">&quot;r&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=10&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    X = []</span><br><span class="line">    Y = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> A[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">        X.append(np.<span class="built_in">abs</span>(T-Tc) * L)</span><br><span class="line">    <span class="keyword">for</span> M <span class="keyword">in</span> A[<span class="number">1</span>][<span class="number">2</span>]:</span><br><span class="line">        Y.append(M * np.power(L,<span class="number">1</span>/<span class="number">8</span>))</span><br><span class="line">    plt.loglog(X,Y, <span class="string">&#x27;.&#x27;</span>,color = <span class="string">&quot;b&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=20&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    X = []</span><br><span class="line">    Y = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> A[<span class="number">2</span>][<span class="number">0</span>]:</span><br><span class="line">        X.append(np.<span class="built_in">abs</span>(T-Tc) * L)</span><br><span class="line">    <span class="keyword">for</span> M <span class="keyword">in</span> A[<span class="number">2</span>][<span class="number">2</span>]:</span><br><span class="line">        Y.append(M * np.power(L,<span class="number">1</span>/<span class="number">8</span>))</span><br><span class="line">    plt.loglog(X,Y, <span class="string">&#x27;.&#x27;</span>,color = <span class="string">&quot;g&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=30&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_exponent_chi</span>(<span class="params">A,<span class="type">List</span></span>):                                      <span class="comment"># 画临界指数 X ~ |T-Tc|^(-gamma)</span></span><br><span class="line">    </span><br><span class="line">    plt.figure(figsize = (<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;|T-Tc|*L&#x27;</span>)  </span><br><span class="line">    plt.ylabel(<span class="string">&#x27;&lt;X&gt;*L^(-7/4)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    X = []</span><br><span class="line">    Y = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> A[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">        X.append(np.<span class="built_in">abs</span>(T-Tc) * L)</span><br><span class="line">    <span class="keyword">for</span> Chi <span class="keyword">in</span> A[<span class="number">0</span>][<span class="number">3</span>]:</span><br><span class="line">        Y.append(Chi * np.power(L,-<span class="number">7</span>/<span class="number">4</span>))</span><br><span class="line">    plt.loglog(X,Y, <span class="string">&#x27;.&#x27;</span>, color = <span class="string">&quot;r&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=10&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    X = []</span><br><span class="line">    Y = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> A[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">        X.append(np.<span class="built_in">abs</span>(T-Tc) * L)</span><br><span class="line">    <span class="keyword">for</span> Chi <span class="keyword">in</span> A[<span class="number">1</span>][<span class="number">3</span>]:</span><br><span class="line">        Y.append(Chi * np.power(L,-<span class="number">7</span>/<span class="number">4</span>))</span><br><span class="line">    plt.loglog(X,Y, <span class="string">&#x27;.&#x27;</span>,color = <span class="string">&quot;b&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=20&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    X = []</span><br><span class="line">    Y = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> A[<span class="number">2</span>][<span class="number">0</span>]:</span><br><span class="line">        X.append(np.<span class="built_in">abs</span>(T-Tc) * L)</span><br><span class="line">    <span class="keyword">for</span> Chi <span class="keyword">in</span> A[<span class="number">2</span>][<span class="number">3</span>]:</span><br><span class="line">        Y.append(Chi * np.power(L,-<span class="number">7</span>/<span class="number">4</span>))</span><br><span class="line">    plt.loglog(X,Y, <span class="string">&#x27;.&#x27;</span>,color = <span class="string">&quot;g&quot;</span>, marker =<span class="string">&quot;o&quot;</span>, label = <span class="string">&quot;L=30&quot;</span>,alpha=<span class="number">0.45</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">draw_exponent_M(Ans,<span class="type">List</span>) </span><br><span class="line"></span><br><span class="line">draw_exponent_chi(Ans,<span class="type">List</span>) </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>​    </p>
<ul>
<li><p>平均能、磁化强度、磁化率和热容对应的比较好，可以确定 Tc 的范围，但受限于算法的复杂度，要想提高精度则需要更长的 Iteration，意味着更长的耗时。</p>
</li>
<li><p>这里我在本地运行 Iteration = 600000(6*10^5)结果截图如下(大约半小时)：</p>
  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/24/at3PQCLDpwBOTZM.png style="zoom:60%" />   
  </div>

  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/24/dm5AFZ86Vj12JnW.png style="zoom:50%" />   
  </div>

  <div  align="center">    
  <img src=https://s2.loli.net/2022/11/24/PSXUBoYHsJ5WdFx.png style="zoom:50%" />   
  </div>
</li>
<li><p>和 1/8 (-7/4) 的精确解斜率符合得较好</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computational Quantum Physics</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
  <entry>
    <title>A bit theory of nonadiabatic dynamics</title>
    <url>/2022/11/24/Eh&amp;TSH/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nonadiabatic-Dynamics"><a href="#Nonadiabatic-Dynamics" class="headerlink" title="Nonadiabatic Dynamics"></a>Nonadiabatic Dynamics</h2><h3 id="1-Ehrenfest-Dynamics"><a href="#1-Ehrenfest-Dynamics" class="headerlink" title="1. Ehrenfest Dynamics"></a><strong>1. Ehrenfest Dynamics</strong></h3><p>We use a single-configuration Ansatz for the total wavefunction:</p>
<script type="math/tex; mode=display">
\Psi(\boldsymbol{r}, \boldsymbol{R}, t)=\Phi(\boldsymbol{r}, t) \Omega(\boldsymbol{R}, t) \exp \left[\frac{i}{\hbar} \int_{t_0}^t d t^{\prime} E_{e l}\left(t^{\prime}\right)\right] .</script><p>The exponential part  is called the “phase term”:</p>
<script type="math/tex; mode=display">
\begin{gathered}
E_{e l}(t)=\iint d r d \boldsymbol{R} \Phi^*(\boldsymbol{r}, t) \Omega^*(\boldsymbol{R}, t) \hat{\mathcal{H}}_{e l}(\boldsymbol{r}, \boldsymbol{R}) 
\times \Phi(\boldsymbol{r}, t) \Omega(\boldsymbol{R}, t)
\end{gathered}</script><p>Insert the representation into TDSE,  left multiplication by $\Omega^*(R, t)$  and integrating over R：</p>
<script type="math/tex; mode=display">
\begin{aligned}
i \hbar  \frac{\partial \Phi(r, t)}{\partial t}=& -\frac{\hbar^2}{2} \sum_j \nabla_i^2 \Phi(r, t)\\
&+\left[\int d R \Omega^*(R, t) \hat{V}(r, R) \Omega(R, t)\right] \Phi(r, t) 
\end{aligned} \tag1</script><p>Similarly,</p>
<script type="math/tex; mode=display">
\begin{aligned}
i \hbar  \frac{\partial \Omega(\boldsymbol{R}, t)}{\partial t}&=-\frac{\hbar^2}{2} \sum_\gamma M_\gamma^{-1} \nabla_\gamma^2 \Omega(\boldsymbol{R}, t) \\
& +\left[\int d r \Phi^*(r, t) \hat{\mathcal{H}}_{e /}(r, R) \Phi(r, t)\right] \Omega(\boldsymbol{R}, t) .
\end{aligned} \tag 2</script><p> forms the so-called mean-field time-dependent self-consistent field (TDSCF) method.</p>
<h4 id="1-1-The-Time-Dependent-Nuclear-Equation"><a href="#1-1-The-Time-Dependent-Nuclear-Equation" class="headerlink" title="1.1  The Time-Dependent Nuclear Equation"></a>1.1  The Time-Dependent Nuclear Equation</h4><p>The  polar representation:</p>
<script type="math/tex; mode=display">
\Omega(\boldsymbol{R}, t)=A(\boldsymbol{R}, t) \exp \left[\frac{i}{\hbar} S(\boldsymbol{R}, t)\right] \tag3</script><p>Insert (3) into (2):</p>
<script type="math/tex; mode=display">
\begin{aligned}
i \hbar & \frac{\partial A(\boldsymbol{R}, t)}{\partial t}-A(\boldsymbol{R}, t) \frac{\partial S(\boldsymbol{R}, t)}{\partial t}=\\
&-\frac{\hbar^2}{2} \sum_\gamma M_\gamma^{-1} \nabla_\gamma^2 A(\boldsymbol{R}, t) 
-i \hbar \sum_\gamma M_\gamma^{-1} \nabla_\gamma A(\boldsymbol{R}, t) \cdot \nabla_\gamma S(\boldsymbol{R}, t) \\
&-\frac{i \hbar}{2} \sum_\gamma M_\gamma^{-1} A(\boldsymbol{R}, t) \nabla_\gamma^2 S(\boldsymbol{R}, t) 
+\frac{1}{2} \sum_\gamma M_\gamma^{-1} A(\boldsymbol{R}, t)\left(\nabla_\gamma S(\boldsymbol{R}, t)\right)^2 \\
&+\left[\int_\gamma \Phi^*(\boldsymbol{r}, t) \hat{\mathcal{H}}_{e /}(\boldsymbol{r}, \boldsymbol{R}) \Phi(\boldsymbol{r}, t)\right] A(\boldsymbol{R}, t) .
\end{aligned}</script><p>Taking the classical limit:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial S(R, t)}{\partial t}=&-\frac{1}{2} \sum_\gamma M_\gamma^{-1}\left(\nabla_\gamma S(R, t)\right)^2 \\
&-\left[\int d r \Phi^*(r, t) \hat{\mathcal{H}}_{e l}(r, R) \Phi(r, t)\right] 
\end{aligned}\tag 4</script><p>Like the “Hamilton–Jacobi” (HJ) equation, </p>
<script type="math/tex; mode=display">
\mathbf{P}\left(t_0\right)=\left.\nabla_{\mathbf{R}} S(\mathbf{R})\right|_{\mathbf{R}\left(t_0\right)}</script><p>We obtain the Newton-like equation for the nuclear trajectories corresponding to the HJ Equation (4):</p>
<script type="math/tex; mode=display">
\frac{d \boldsymbol{P}_\gamma(t)}{d t}=-\nabla_\gamma\left[\int d r \Phi^*(\boldsymbol{r}, t) \hat{\mathcal{H}}_{e l}(\boldsymbol{r}, \boldsymbol{R}(t)) \Phi(\boldsymbol{r}, t)\right]</script><p>or </p>
<script type="math/tex; mode=display">
M_\gamma \ddot{R}_\gamma(t)=-\nabla_\gamma\left\langle\hat{\mathcal{H}}_{e l}(\boldsymbol{r}, \boldsymbol{R}(t))\right\rangle \tag 5</script><h4 id="1-2-The-Time-Dependent-Electronic-Equation"><a href="#1-2-The-Time-Dependent-Electronic-Equation" class="headerlink" title="1.2   The Time-Dependent Electronic Equation"></a>1.2   The Time-Dependent Electronic Equation</h4><p>We take the classical limit of the nuclear degrees of freedom:</p>
<script type="math/tex; mode=display">
|\Omega(\boldsymbol{R}, t)|^2=\prod_\gamma \delta\left(\boldsymbol{R}_\gamma-\boldsymbol{R}_\gamma(t)\right)</script><script type="math/tex; mode=display">
i \hbar \frac{\partial \Phi(r ; R(t), t)}{\partial t}=\hat{\mathcal{H}}_{e l}(r, R(t)) \Phi(r ; R(t), t)</script><h3 id="2-BO-MD-and-Its-Nonadiabatic-Extensions"><a href="#2-BO-MD-and-Its-Nonadiabatic-Extensions" class="headerlink" title="2. BO-MD and Its Nonadiabatic Extensions"></a><strong>2. BO-MD and Its Nonadiabatic Extensions</strong></h3><script type="math/tex; mode=display">
\Psi(\boldsymbol{r}, \boldsymbol{R}, t)=\sum_i^{\infty} \Omega_i(\boldsymbol{R}, t) \Phi_i(\boldsymbol{r} ; \boldsymbol{R})\tag 6</script><script type="math/tex; mode=display">
\hat{\mathcal{H}}_{e l}(r, R) \Phi_i(r ; R)=E_i^{e l}(R) \Phi_i(r ; R)</script><p>Similarly,</p>
<script type="math/tex; mode=display">
\begin{aligned}
i \hbar \frac{\partial}{\partial t} \Omega_j(R, t)=& {\left[-\sum_\gamma \frac{\hbar^2}{2 M_\gamma} \nabla_\gamma^2+E_j^{e l}(R)\right] \Omega_j(R, t) } \\
&+\sum_j^{\infty} \mathcal{F}_{j i} \Omega_i(R, t) .
\end{aligned}\tag 7</script><script type="math/tex; mode=display">
\begin{aligned}
&\mathcal{F}_{j i}(\boldsymbol{R})=\int d \boldsymbol{r} \Phi_j^*(\boldsymbol{r}: \boldsymbol{R})\left[-\sum_\gamma \frac{\hbar^2}{2 M_\gamma} \nabla_\gamma^2\right] \Phi_i(\boldsymbol{r};\boldsymbol{R}) \\
&\quad+\sum_\gamma \frac{1}{M_\gamma}\left\{\int d r \Phi_j^*(\boldsymbol{r} ; \boldsymbol{R})\left[-i \hbar \nabla_\gamma\right] \Phi_i(\boldsymbol{r} ; \boldsymbol{R})\right\}\times\left[-i \hbar \nabla_\gamma\right] 
\end{aligned}\tag 8</script><h4 id="2-1-The-Adiabatic-BOA"><a href="#2-1-The-Adiabatic-BOA" class="headerlink" title="2.1 The Adiabatic BOA"></a>2.1 The Adiabatic BOA</h4><p>Only remain diagonal terms （diagonal correction）:</p>
<script type="math/tex; mode=display">
\mathcal{F}_{j j}(\boldsymbol{R})=\int d \boldsymbol{r} \Phi_j^*(\boldsymbol{r} ; \boldsymbol{R})\left[-\sum_\gamma \frac{\hbar^2}{2 M_\gamma} \nabla_\gamma^2\right] \Phi_j(\boldsymbol{r} ; \boldsymbol{R})\tag 9</script><p>As in 1.1,let all Fji(R) = 0,insert (10) into (7):</p>
<script type="math/tex; mode=display">
\Omega_j(\boldsymbol{R}, t)=A_j(\boldsymbol{R}, t) \exp \left[\frac{i}{\hbar} S_j(\boldsymbol{R}, t)\right] .\tag {10}</script><script type="math/tex; mode=display">
\frac{\partial S_j(R, t)}{\partial t}=-\frac{1}{2} \sum M_\gamma^{-1}\left(\nabla_\gamma S_j(R, t)\right)^2-E_j^{e l}(\boldsymbol{R}) \tag{11}</script><p>Using the relation </p>
<script type="math/tex; mode=display">
\left.\nabla_\gamma S_j\right|_{\mathbf{R}(t)}=\mathbf{P}_j^\gamma(t)</script><p>obtain a Newton-like equation of motion for the “classical” nuclei evolving in electronic state j :</p>
<script type="math/tex; mode=display">
M_\gamma \boldsymbol{R}_j^\gamma(t)=-\nabla_\gamma E_j^{e l}(\boldsymbol{R}(t))</script><p>In summary, the BO-MD equations:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\hat{\mathcal{H}}_{e l}(r, R(t)) \Phi_j(r ; \boldsymbol{R}(t))=E_j^{e l}(\boldsymbol{R}(t)) \Phi_j(r ; R(t))\\
&\begin{aligned}
M_\gamma \ddot{R}_j^\gamma(t) &=-\nabla_\gamma E_j^{e l}(R(t)) \\
&=-\nabla_\gamma\underset{\min \Phi_j}{ }\left\langle\Phi_j\left|\hat{\mathcal{H}}_{el}(\boldsymbol{r}, \boldsymbol{R}(t))\right| \Phi_j\right\rangle,
\end{aligned}
\end{aligned}</script><p>Due to the assumption that  Fji =0, BO-MD always evolves on a single electronic PES( ground state).</p>
<h4 id="2-2-Trajectory-Based-Nonadiabatic-Dynamics"><a href="#2-2-Trajectory-Based-Nonadiabatic-Dynamics" class="headerlink" title="2.2. Trajectory-Based Nonadiabatic Dynamics"></a>2.2. Trajectory-Based Nonadiabatic Dynamics</h4><p>Rewrite (7) into :</p>
<script type="math/tex; mode=display">
\begin{aligned}
i \hbar \frac{\partial \Omega_j(R, t)}{\partial t}=&-\sum_\gamma \frac{\hbar^2}{2 M_\gamma} \nabla_\gamma^2 \Omega_j(R, t) \\
&+E_j^{e l}(R) \Omega_j(R, t) \\
&+\sum_{\gamma i} \frac{\hbar^2}{2 M_\gamma} D_{j i}^\gamma(R) \Omega_i(R, t) \\
&-\sum_{\gamma, i \neq j} \frac{\hbar^2}{M_\gamma} d_{j i}^\gamma(R) \cdot \nabla_\gamma \Omega_i(R, t)
\end{aligned}\tag {12}</script><p>where</p>
<script type="math/tex; mode=display">
d_{j i}^\gamma(R)=\int d r \Phi_j^*(r ; R) \nabla_\gamma \Phi_i(r ; R)</script><script type="math/tex; mode=display">
D_{j i}^\gamma(R)=-\int d r \Phi_j^*(r ; R) \nabla_\gamma^2 \Phi_i(r ; R)</script><h4 id="2-3-The-Nonadiabatic-Bohmian-Dynamics-NABDY-Equations"><a href="#2-3-The-Nonadiabatic-Bohmian-Dynamics-NABDY-Equations" class="headerlink" title="2.3 The Nonadiabatic Bohmian Dynamics (NABDY) Equations"></a>2.3 The Nonadiabatic Bohmian Dynamics (NABDY) Equations</h4><p>The polar representation (10) in Eq(12):</p>
<script type="math/tex; mode=display">
\begin{aligned}
-& \frac{\partial S_j(\boldsymbol{R}, t)}{\partial t}=\sum_\gamma \frac{1}{2 M_\gamma}\left(\nabla_\gamma S_j(\boldsymbol{R}, t)\right)^2+E_j^{e \prime}(\boldsymbol{R}) \\
&-\sum_\gamma \frac{\hbar^2}{2 M_\gamma} \frac{\nabla_\gamma^2 A_j(\boldsymbol{R}, t)}{A_j(\boldsymbol{R}, t)} \\
&+\sum_{\gamma i} \frac{\hbar^2}{2 M_\gamma} D_{j i}^\gamma(\boldsymbol{R}) \frac{A_i(\boldsymbol{R}, t)}{A_j(\boldsymbol{R}, t)} \Re\left[e^{i \phi_{i j}(R, t)}\right] \\
&-\sum_{\gamma, i \neq j} \frac{\hbar^2}{M_\gamma} \boldsymbol{d}_{j i}^\gamma(\boldsymbol{R}) \cdot \frac{\nabla_\gamma A_i(\boldsymbol{R}, t)}{A_j(\boldsymbol{R}, t)} \Re\left[e^{i \phi_{i j}(\boldsymbol{R}, t)}\right] \\
&+\sum_{\gamma, i \neq j} \frac{\hbar}{M_\gamma} \frac{A_j(\boldsymbol{R}, t)}{A_j(\boldsymbol{R}, t)} \boldsymbol{d}_{j i}^\gamma(\boldsymbol{R}) \cdot \nabla_\gamma S_i(\boldsymbol{R}, t) \\
& \times \Im\left[e^{i \phi_{i j}(\boldsymbol{R}, t)}\right]
\end{aligned}\tag{13}</script><p>and </p>
<script type="math/tex; mode=display">
\begin{aligned}
&\hbar \frac{\partial A_j(R, t)}{\partial t}=-\sum_\gamma \frac{\hbar}{M_\gamma} \nabla_\gamma A_j(R, t) \cdot \nabla_\gamma S_j(R, t) \\
&-\sum_\gamma \frac{\hbar}{2 M_\gamma} A_j(R, t) \nabla_\gamma^2 S_j(R, t) \\
&+\sum_{\gamma i} \frac{\hbar^2}{2 M_\gamma} D_{j i}^\gamma(R) A_i(R, t) \Im\left[e^{i \phi_{i j}(R, t)}\right] \\
&-\sum_{\gamma, i \neq j} \frac{\hbar^2}{M_\gamma} d_{j i}^\gamma(R) \cdot \nabla_\gamma A_i(R, t) \Im\left[e^{i \phi_{i j}(R, t)}\right] \\
&-\sum_{\gamma, i \neq j} \frac{\hbar}{M_\gamma} A_i(R, t) d_{j i}^\gamma(R) \cdot \nabla_\gamma S_i(R, t) \\
&\times \Re\left[e^{i \phi_{i j}(R, t)}\right]  \\
&
\end{aligned}\tag{14}</script><p>where </p>
<script type="math/tex; mode=display">
\phi_{ij}(\mathbf{R},t)= \frac{1}{\hbar}\left(S_i(\mathbf{R}, t)-S_j(\mathbf{R}, t)\right)</script><p>(13)(14) correspond to the exact S.Eq. for a nuclear-wave-func. evolving in the potential of the different elec-surfaces.            invlove fo-,so-, coupling elements from other PESs.</p>
<p>In (13), 1,2-terms: classical H-J eq for action S;      3-term: all quantum effects in a single elec-state and introduce nonlocality;    4,5,6-terms: non-adiabatic quantum potential, describle interstate contributions.     Use HJ definition </p>
<script type="math/tex; mode=display">
\left.\nabla_\beta S_j(\mathbf{R}, t)\right|_{\mathbf{R}(t)}=\mathbf{P}_j^\beta(t)</script><p>have </p>
<script type="math/tex; mode=display">
\begin{aligned}
M_\beta \frac{d^2 \boldsymbol{R}_\beta(t)}{\left(d t^j\right)^2}=&-\nabla_\beta\left[E_j^{e l}(\boldsymbol{R}(t))+\mathcal{Q}_j(\boldsymbol{R}(t), t)\right.\\
&\left.+\sum_i \mathcal{D}_{j i}(\boldsymbol{R}(t), t)\right]
\end{aligned}\tag{15}</script><h4 id="2-4-The-TSH-Dynamics"><a href="#2-4-The-TSH-Dynamics" class="headerlink" title="2.4 The TSH Dynamics"></a>2.4 The TSH Dynamics</h4><p>An approximation to the “in principle” exact NABDY formulation of the nuclear equations of motion.</p>
<p>From (13),(14):</p>
<script type="math/tex; mode=display">
\begin{aligned}
-& \frac{\partial S_j(\boldsymbol{R}, t)}{\partial t}=\sum_\gamma \frac{1}{2 M_\gamma}\left(\nabla_\gamma S_j(\boldsymbol{R}, t)\right)^2+E_j^{e l}(\boldsymbol{R}) \\
&+\sum_{\gamma, i \neq j} \frac{\hbar}{M_\gamma} \frac{A_i(\boldsymbol{R}, t)}{A_j(\boldsymbol{R}, t)} \boldsymbol{d}_{j i}^\gamma(\boldsymbol{R}) \cdot \nabla_\gamma S_i(\boldsymbol{R}, t) \\
& \times \Im\left[e^{i \phi_{i j}(R, t)}\right]
\end{aligned}\tag{16}</script><script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial A_j(\boldsymbol{R}, t)}{\partial t}=&-\sum_\gamma \frac{1}{M_\gamma} \nabla_\gamma A_j(\boldsymbol{R}, t) \cdot \nabla_\gamma S_j(\boldsymbol{R}, t) \\
&-\sum_\gamma \frac{1}{2 M_\gamma} A_j(\boldsymbol{R}, t) \nabla_\gamma^2 S_j(\boldsymbol{R}, t) \\
&-\sum_{\gamma, i \neq j} \frac{1}{M_\gamma} A_i(\boldsymbol{R}, t) \boldsymbol{d}_{j i}^\gamma(\boldsymbol{R}) \cdot \nabla_\gamma S_i(\boldsymbol{R}, t) \\
& \times \Re\left[e^{i \phi_{i j}(R, t)}\right] .
\end{aligned}\tag{17}</script><p>Consider this “classically”:the different trajectories (with different initial conditions) are assumed to be independent from each other. （ITA）</p>
<script type="math/tex; mode=display">
\left(A_j^{C L}(R(t), t)\right)^2=\frac{N_j(R(t), d V, t)}{N_t} \frac{1}{d V}</script><p>In TSH, the EOM of nuclear trajectories given by (16) , which independent with d：</p>
<script type="math/tex; mode=display">
\frac{d \boldsymbol{P}_j^\beta(t)}{d t^j}=-\nabla_\beta E_j^{e l}(\boldsymbol{R}(t))\tag{18}</script><p>If NACs are negligible, the trajectories evolve along the adiabatic PES.</p>
<p>If a region of strong coupling is encountered:</p>
<script type="math/tex; mode=display">
\begin{aligned}
-& \frac{\partial S_j^{Q M}(\boldsymbol{R}(t), t)}{\partial t}=E_j^{e l}(\boldsymbol{R}(t)) +\sum_{\gamma, i \neq j} \frac{\hbar}{M_\gamma} \frac{A_i^{Q M}(\boldsymbol{R}(t), t)}{A_j^{Q M}(\boldsymbol{R}(t), t)} \times \boldsymbol{d}_{j i}^\gamma(\boldsymbol{R}(t)) \cdot \dot{R}_\gamma(t) \Im\left[e^{i \phi_{i j}^{Q M}(R(t), t)}\right]
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial A_j^{Q M}(R(t), t)}{\partial t}=-\sum_{\gamma, i \neq j} \frac{1}{M_\gamma} A_i^{Q M}(R(t), t)\times \boldsymbol{d}_{j i}^\gamma(\boldsymbol{R}(t)) \cdot \dot{R}_\gamma(t) \Re\left[e^{i \phi_{i j}^{Q M}(R(t), t)}\right]
\end{aligned}</script><p>i.e.</p>
<script type="math/tex; mode=display">
\begin{aligned}
i \hbar & \frac{\partial C_j(\boldsymbol{R}(t), t)}{\partial t}=C_j(\boldsymbol{R}(t), t) E_j^{\mathrm{el}}(\boldsymbol{R}(t)) -i \hbar \sum_i\left(\boldsymbol{d}_{j i}(\boldsymbol{R}(t)) \cdot \boldsymbol{R}(t) C_i(\boldsymbol{R}(t), t)\right)
\end{aligned}\tag{19}</script><p>with </p>
<script type="math/tex; mode=display">
C_j(\mathbf{R}(t), t)=A_j^{\mathrm{QM}}(\mathbf{R}(t), t) \exp \left[\frac{i}{\hbar} S_j^{\mathrm{QM}}(\mathbf{R}(t), t)\right]</script><p>In TSH , after enough sampling, internal consistency criterion:</p>
<script type="math/tex; mode=display">
\left(A_j^{C L}(R(t), t)\right)^2=\left(A_j^{Q M}(R(t), t)\right)^2</script><p>Tully gives:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&p_{i \leftarrow j}^{[\alpha]}(t, t+\Delta t)= \\
&-2 \int_t^{t+\Delta t} d \tau \frac{\Re\left[C_i^{[\alpha]}(\tau) C_j^{[\alpha] *}(\tau) \boldsymbol{R}(\tau) \cdot \boldsymbol{d}_{i j}(\boldsymbol{R}(\tau))\right]}{C_j^{[\alpha]}(\tau) C_j^{[\alpha] *}(\tau)}
\end{aligned}\tag{20}</script><p>Reference：</p>
<p>D. Marx, J. Hutter, Ab Initio Molecular Dynamics: Basic Theory and Advanced Methods, Cambridge University Press, Cambridge, 20</p>
]]></content>
      <categories>
        <category>Some Notes</category>
      </categories>
      <tags>
        <tag>physics</tag>
      </tags>
  </entry>
</search>
